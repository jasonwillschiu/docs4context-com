# METADATA
# TOKEN_COUNT: 74035
# DATE_CREATED: 2025-06-26T01:58:40Z
# REPO: mark3labs/mcp-go
# SOURCE: https://context7.com/mark3labs/mcp-go/llms.txt
#
TITLE: Create a basic MCP server in Go
DESCRIPTION: Demonstrates the fundamental way to initialize an MCP server instance using `server.NewMCPServer()` with a name and version, and then starts it using the Stdio transport.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a basic server
    s := server.NewMCPServer(
        "My MCP Server",  // Server name
        "1.0.0"          // Server version
    )
    
    // Start the server (stdio transport)
    server.ServeStdio(s)
}
```

----------------------------------------

TITLE: Implement Panic Recovery and Error Handling in Go Servers
DESCRIPTION: This Go snippet shows how to enhance server robustness by enabling panic recovery and handling server startup and shutdown errors. It uses server.WithRecovery() to catch panics and checks for server.ErrServerClosed to differentiate between graceful shutdowns and other server errors.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_11

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("Error-Safe Server", "1.0.0",
        server.WithRecovery(), // Panic recovery
    )
    
    // Add error handling for server startup
    if err := server.ServeStdio(s); err != nil {
        if errors.Is(err, server.ErrServerClosed) {
            log.Println("Server closed gracefully")
        } else {
            log.Fatalf("Server error: %v", err)
        }
    }
}
```

----------------------------------------

TITLE: Manage HTTP Sessions with Go
DESCRIPTION: This Go code defines an `HTTPSessionManager` for handling user sessions, including creation, retrieval, and automatic cleanup of expired sessions. It uses `sync.RWMutex` for thread-safe access to session data and `time.Ticker` for periodic cleanup, ensuring efficient and concurrent session management.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_12

LANGUAGE: go
CODE:
```
type HTTPSessionManager struct {
    sessions map[string]*HTTPSession
    mutex    sync.RWMutex
    cleanup  *time.Ticker
}

type HTTPSession struct {
    ID          string
    UserID      string
    CreatedAt   time.Time
    LastAccess  time.Time
    Data        map[string]interface{}
    ExpiresAt   time.Time
}

func NewHTTPSessionManager() *HTTPSessionManager {
    sm := &HTTPSessionManager{
        sessions: make(map[string]*HTTPSession),
        cleanup:  time.NewTicker(1 * time.Minute),
    }
    
    go sm.cleanupExpiredSessions()
    return sm
}

func (sm *HTTPSessionManager) CreateSession(userID string) *HTTPSession {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    session := &HTTPSession{
        ID:         generateSessionID(),
        UserID:     userID,
        CreatedAt:  time.Now(),
        LastAccess: time.Now(),
        Data:       make(map[string]interface{}),
        ExpiresAt:  time.Now().Add(30 * time.Minute),
    }
    
    sm.sessions[session.ID] = session
    return session
}

func (sm *HTTPSessionManager) GetSession(sessionID string) (*HTTPSession, bool) {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    session, exists := sm.sessions[sessionID]
    if !exists || time.Now().After(session.ExpiresAt) {
        return nil, false
    }
    
    // Update last access
    session.LastAccess = time.Now()
    session.ExpiresAt = time.Now().Add(30 * time.Minute)
    
    return session, true
}

func (sm *HTTPSessionManager) cleanupExpiredSessions() {
    for range sm.cleanup.C {
        sm.mutex.Lock()
        now := time.Now()
        
        for id, session := range sm.sessions {
            if now.After(session.ExpiresAt) {
                delete(sm.sessions, id)
            }
        }
        
        sm.mutex.Unlock()
    }
}
```

----------------------------------------

TITLE: Initialize and Run Production MCP Server with Graceful Shutdown (Go)
DESCRIPTION: This Go code defines the `main` function for an MCP production server, demonstrating the initialization of core components like loggers, metrics, and session managers. It configures various middleware (logging, rate limiting, authentication) and hooks (telemetry, business) before creating and starting the server. The `startWithGracefulShutdown` function ensures the server handles OS signals for a clean shutdown, preventing data loss.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_14

LANGUAGE: go
CODE:
```
func main() {
    // Initialize components
    logger := log.New(os.Stdout, "[MCP] ", log.LstdFlags)
    metrics := NewPrometheusMetrics()
    sessionManager := NewSessionManager()
    notifier := NewCustomNotifier()
    
    // Create middleware
    loggingMW := NewLoggingMiddleware(logger)
    rateLimitMW := NewRateLimitMiddleware(10.0, 20) // 10 req/sec, burst 20
    authMW := NewAuthMiddleware(NewJWTValidator())
    
    // Create hooks
    telemetryHooks := NewTelemetryHooks(metrics, logger)
    businessHooks := NewBusinessHooks(NewAuditLogger(), NewSlackNotifier())
    
    // Create server with all features
    s := server.NewMCPServer("Production Server", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithResourceCapabilities(false, true),
        server.WithPromptCapabilities(true),
        server.WithRecovery(),
        server.WithHooks(telemetryHooks),
        server.WithToolHandlerMiddleware(loggingMW.ToolMiddleware),
        server.WithToolFilter(NewPermissionFilter(sessionManager)),
    )
    
    // Add tools and resources
    addProductionTools(s)
    addProductionResources(s)
    addProductionPrompts(s)
    
    // Start server with graceful shutdown
    startWithGracefulShutdown(s)
}

func startWithGracefulShutdown(s *server.MCPServer) {
    // Setup signal handling
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    
    // Start server in goroutine
    go func() {
        if err := server.ServeStdio(s); err != nil {
            log.Printf("Server error: %v", err)
        }
    }()
    
    // Wait for shutdown signal
    <-sigChan
    log.Println("Shutting down server...")
    
    // Graceful shutdown with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := s.Shutdown(ctx); err != nil {
        log.Printf("Shutdown error: %v", err)
    }
    
    log.Println("Server stopped")
}
```

----------------------------------------

TITLE: Complete MCP Client Example in Go
DESCRIPTION: This comprehensive Go example demonstrates how to create an STDIO MCP client, initialize the connection, discover available capabilities, list tools and resources, and perform tool calls and resource reads.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

func main() {
    // Create STDIO client
    c, err := client.NewStdioMCPClient(
        "go", []string{} , "run", "/path/to/server/main.go",
    )
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()

    ctx := context.Background()

    // Initialize the connection
    if err := c.Initialize(ctx, initRequest); err != nil {
        log.Fatal(err)
    }

    // Discover available capabilities
    if err := demonstrateClientOperations(ctx, c); err != nil {
        log.Fatal(err)
    }
}

func demonstrateClientOperations(ctx context.Context, c client.Client) error {
    // List available tools
    tools, err := c.ListTools(ctx)
    if err != nil {
        return fmt.Errorf("failed to list tools: %w", err)
    }

    fmt.Printf("Available tools: %d\n", len(tools.Tools))
    for _, tool := range tools.Tools {
        fmt.Printf("- %s: %s\n", tool.Name, tool.Description)
    }

    // List available resources
    resources, err := c.ListResources(ctx)
    if err != nil {
        return fmt.Errorf("failed to list resources: %w", err)
    }

    fmt.Printf("\nAvailable resources: %d\n", len(resources.Resources))
    for _, resource := range resources.Resources {
        fmt.Printf("- %s: %s\n", resource.URI, resource.Name)
    }

    // Call a tool if available
    if len(tools.Tools) > 0 {
        tool := tools.Tools[0]
        fmt.Printf("\nCalling tool: %s\n", tool.Name)

        result, err := c.CallTool(ctx, mcp.CallToolRequest{
            Params: mcp.CallToolRequestParams{
                Name: tool.Name,
                Arguments: map[string]interface{}{
                    "input": "example input",
                    "format": "text"
                }
            }
        })
        if err != nil {
            return fmt.Errorf("tool call failed: %w", err)
        }

        fmt.Printf("Tool result: %+v\n", result)
    }

    // Read a resource if available
    if len(resources.Resources) > 0 {
        resource := resources.Resources[0]
        fmt.Printf("\nReading resource: %s\n", resource.URI)

        content, err := c.ReadResource(ctx, mcp.ReadResourceRequest{
            Params: mcp.ReadResourceRequestParams{
                URI: resource.URI
            }
        })
        if err != nil {
            return fmt.Errorf("resource read failed: %w", err)
        }

        fmt.Printf("Resource content: %+v\n", content)
    }

    return nil
}
```

----------------------------------------

TITLE: Implement a Basic STDIO Server with File Tools in Go
DESCRIPTION: This Go program sets up an `mcp-go` STDIO server that exposes file system operations. It defines a `list_files` tool to enumerate directory contents (with optional recursion) and a `file://{path}` resource to read file content. The server includes handlers (`handleListFiles`, `handleFileContent`) for these operations, along with helper functions (`isValidPath`, `listFiles`, `extractPathFromURI`, `detectMIMEType`) for security and utility.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
    "context"
    "fmt"
    "os"
    "path/filepath"
    "strings"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    s := server.NewMCPServer("File Tools", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithResourceCapabilities(true, true),
    )

    // Add file listing tool
    s.AddTool(
        mcp.NewTool("list_files",
            mcp.WithDescription("List files in a directory"),
            mcp.WithString("path", 
                mcp.Required(),
                mcp.Description("Directory path to list"),
            ),
            mcp.WithBoolean("recursive",
                mcp.DefaultBool(false),
                mcp.Description("List files recursively"),
            ),
        ),
        handleListFiles,
    )

    // Add file content resource
    s.AddResource(
        mcp.NewResource(
            "file://{path}",
            "File Content",
            mcp.WithResourceDescription("Read file contents"),
            mcp.WithMIMEType("text/plain"),
        ),
        handleFileContent,
    )

    // Start STDIO server
    if err := server.ServeStdio(s); err != nil {
        fmt.Fprintf(os.Stderr, "Server error: %v\n", err)
        os.Exit(1)
    }
}

func handleListFiles(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    path, err := req.RequireString("path")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    recursive, err := req.RequireBool("recursive")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }

    // Security: validate path
    if !isValidPath(path) {
        return mcp.NewToolResultError(fmt.Sprintf("invalid path: %s", path)), nil
    }

    files, err := listFiles(path, recursive)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to list files: %v", err)), nil
    }

    return mcp.NewToolResultText(fmt.Sprintf(`{"path":"%s","files":%v,"count":%d,"recursive":%t}`, 
        path, files, len(files), recursive)), nil
}

func handleFileContent(ctx context.Context, req mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract path from URI: "file:///path/to/file" -> "/path/to/file"
    path := extractPathFromURI(req.Params.URI)
    
    if !isValidPath(path) {
        return nil, fmt.Errorf("invalid path: %s", path)
    }

    content, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read file: %w", err)
    }

    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: detectMIMEType(path),
            Text:     string(content),
        },
    }, nil
}

func isValidPath(path string) bool {
    // Clean the path to resolve any . or .. components
    clean := filepath.Clean(path)
    
    // Check for directory traversal patterns
    if strings.Contains(clean, "..") {
        return false
    }
    
    // For absolute paths, ensure they're within a safe base directory
    if filepath.IsAbs(clean) {
        // Define safe base directories (adjust as needed for your use case)
        safeBaseDirs := []string{
            "/tmp",
            "/var/tmp", 
            "/home",
            "/Users" // macOS
        }
        
        // Check if the path starts with any safe base directory
        for _, baseDir := range safeBaseDirs {
            if strings.HasPrefix(clean, baseDir) {
                return true
            }
        }
        return false
    }
    
    // For relative paths, ensure they don't escape the current directory
    return !strings.HasPrefix(clean, "..")
}

// Helper functions for the examples
func listFiles(path string, recursive bool) ([]string, error) {
    // Placeholder implementation
    return []string{"file1.txt", "file2.txt"}, nil
}

func extractPathFromURI(uri string) string {
    // Extract path from URI: "file:///path/to/file" -> "/path/to/file"
    if strings.HasPrefix(uri, "file://") {
        return strings.TrimPrefix(uri, "file://")
    }
    return uri
}

func detectMIMEType(path string) string {
    // Simple MIME type detection based on extension
    ext := filepath.Ext(path)
    switch ext {
    case ".txt":
        return "text/plain"
    case ".json":
        return "application/json"
    case ".html":
        return "text/html"
    default:
        return "application/octet-stream"
    }
}
```

----------------------------------------

TITLE: Creating a Basic MCP Server with Calculator Tool in Go
DESCRIPTION: This snippet demonstrates how to initialize an MCP server, add a 'calculator' tool with defined arguments (operation, x, y), and implement its handler logic for basic arithmetic operations. It showcases the use of 'mcp.NewTool' for tool definition and 'request.RequireString/Float' for type-safe argument access, along with starting the server via standard I/O.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_2

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "Calculator Demo",
        "1.0.0",
        server.WithToolCapabilities(false),
        server.WithRecovery(),
    )

    // Add a calculator tool
    calculatorTool := mcp.NewTool("calculate",
        mcp.WithDescription("Perform basic arithmetic operations"),
        mcp.WithString("operation",
            mcp.Required(),
            mcp.Description("The operation to perform (add, subtract, multiply, divide)"),
            mcp.Enum("add", "subtract", "multiply", "divide"),
        ),
        mcp.WithNumber("x",
            mcp.Required(),
            mcp.Description("First number"),
        ),
        mcp.WithNumber("y",
            mcp.Required(),
            mcp.Description("Second number"),
        ),
    )

    // Add the calculator handler
    s.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        // Using helper functions for type-safe argument access
        op, err := request.RequireString("operation")
        if err != nil {
            return mcp.NewToolResultError(err.Error()), nil
        }
        
        x, err := request.RequireFloat("x")
        if err != nil {
            return mcp.NewToolResultError(err.Error()), nil
        }
        
        y, err := request.RequireFloat("y")
        if err != nil {
            return mcp.NewToolResultError(err.Error()), nil
        }

        var result float64
        switch op {
        case "add":
            result = x + y
        case "subtract":
            result = x - y
        case "multiply":
            result = x * y
        case "divide":
            if y == 0 {
                return mcp.NewToolResultError("cannot divide by zero"), nil
            }
            result = x / y
        }

        return mcp.NewToolResultText(fmt.Sprintf("%.2f", result)), nil
    })

    // Start the server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}
```

----------------------------------------

TITLE: Create a Hello World MCP Server in Go
DESCRIPTION: This Go program sets up a basic MCP server that exposes a 'hello_world' tool. The tool takes a 'name' parameter and returns a greeting. It uses the `mcp-go` library to define the server, tool, and a handler function, serving over standard I/O.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "errors"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "Hello World Server",
        "1.0.0",
        server.WithToolCapabilities(false),
    )

    // Define a simple tool
    tool := mcp.NewTool("hello_world",
        mcp.WithDescription("Say hello to someone"),
        mcp.WithString("name",
            mcp.Required(),
            mcp.Description("Name of the person to greet"),
        ),
    )

    // Add tool handler
    s.AddTool(tool, helloHandler)

    // Start the stdio server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    name, err := request.RequireString("name")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }

    return mcp.NewToolResultText(fmt.Sprintf("Hello, %s! 👋", name)), nil
}
```

----------------------------------------

TITLE: Implement Timeout Handling for Resource Access in Go MCP Server
DESCRIPTION: This Go function demonstrates how to apply context-based timeouts to resource fetching operations in an MCP server. It uses `context.WithTimeout` to ensure operations complete within a specified duration, handling `context.DeadlineExceeded` errors.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_11

LANGUAGE: go
CODE:
```
func handleResourceWithTimeout(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    // Create timeout context
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    // Use context in operations
    data, err := fetchDataWithContext(ctx, req.Params.URI)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            return nil, fmt.Errorf("resource fetch timeout: %s", req.Params.URI)
        }
        return nil, err
    }
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            mcp.TextResourceContent{
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(jsonData),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: StreamableHTTP Connection Pooling
DESCRIPTION: Illustrates a `StreamableHTTPClientPool` implementation for managing and reusing `StreamableHTTP` client instances. This pool helps optimize resource usage by providing methods to `Get` a client from the pool, `Put` it back, or create a new one if the pool is empty, and automatically closes clients if the pool is full.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_7

LANGUAGE: go
CODE:
```
type StreamableHTTPClientPool struct {
    clients chan *client.Client
    factory func() *client.Client
    maxSize int
}

func NewStreamableHTTPClientPool(baseURL string, maxSize int) *StreamableHTTPClientPool {
    pool := &StreamableHTTPClientPool{
        clients: make(chan *client.Client, maxSize),
        maxSize: maxSize,
        factory: func() *client.Client {
            return client.NewStreamableHttpClient(baseURL)
        },
    }

    // Pre-populate pool
    for i := 0; i < maxSize; i++ {
        pool.clients <- pool.factory()
    }

    return pool
}

func (pool *StreamableHTTPClientPool) Get() *client.Client {
    select {
    case c := <-pool.clients:
        return c
    default:
        return pool.factory()
    }
}

func (pool *StreamableHTTPClientPool) Put(c *client.Client) {
    select {
    case pool.clients <- c:
    default:
        // Pool full, close client
        c.Close()
    }
}

func (pool *StreamableHTTPClientPool) CallTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    c := pool.Get()
    defer pool.Put(c)

    return c.CallTool(ctx, req)
}
```

----------------------------------------

TITLE: Implement JWT Authentication Middleware in Go
DESCRIPTION: This Go code provides an `AuthMiddleware` for securing HTTP endpoints using JSON Web Tokens (JWT). It demonstrates how to extract, validate JWTs from authorization headers, load user information, and attach it to the request context, ensuring only authenticated users can access protected resources. It includes a `Claims` struct for JWT payload.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_13

LANGUAGE: go
CODE:
```
type AuthMiddleware struct {
    jwtSecret []byte
    userStore UserStore
}

func NewAuthMiddleware(secret []byte, store UserStore) *AuthMiddleware {
    return &AuthMiddleware{
        jwtSecret: secret,
        userStore: store,
    }
}

func (m *AuthMiddleware) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Extract token from Authorization header
        authHeader := r.Header.Get("Authorization")
        if !strings.HasPrefix(authHeader, "Bearer ") {
            http.Error(w, "Missing or invalid authorization header", http.StatusUnauthorized)
            return
        }
        
        token := strings.TrimPrefix(authHeader, "Bearer ")
        
        // Validate JWT token
        claims, err := m.validateJWT(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // Load user information
        user, err := m.userStore.GetUser(claims.UserID)
        if err != nil {
            http.Error(w, "User not found", http.StatusUnauthorized)
            return
        }
        
        // Add user to request context
        ctx := context.WithValue(r.Context(), "user", user)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func (m *AuthMiddleware) validateJWT(tokenString string) (*Claims, error) {
    // Note: This example uses a hypothetical JWT library
    // In practice, you would use a real JWT library like github.com/golang-jwt/jwt
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return m.jwtSecret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

type Claims struct {
    UserID string `json:"user_id"`
    Role   string `json:"role"`
    jwt.StandardClaims
}
```

----------------------------------------

TITLE: Implement Authentication Middleware in Go
DESCRIPTION: This Go code defines an `AuthMiddleware` that validates an authentication token extracted from the request context or parameters. It uses a `TokenValidator` interface to verify the token and, if valid, adds user information to the context for downstream handlers, ensuring secure access to tools and resources.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_7

LANGUAGE: go
CODE:
```
type AuthMiddleware struct {
    tokenValidator TokenValidator
}

func NewAuthMiddleware(validator TokenValidator) *AuthMiddleware {
    return &AuthMiddleware{tokenValidator: validator}
}

func (m *AuthMiddleware) ToolMiddleware(next server.ToolHandler) server.ToolHandler {
    return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        // Extract token from context or request
        token := extractToken(ctx, req)
        if token == "" {
            return nil, fmt.Errorf("authentication required")
        }
        
        // Validate token
        user, err := m.tokenValidator.Validate(token)
        if err != nil {
            return nil, fmt.Errorf("invalid token: %w", err)
        }
        
        // Add user to context
        ctx = context.WithValue(ctx, "user", user)
        
        return next(ctx, req)
    }
}
```

----------------------------------------

TITLE: Full Go Implementation of an MCP Code Review Prompt
DESCRIPTION: This comprehensive example demonstrates how to set up an MCP server, register a 'code_review' prompt with detailed arguments (code, language, focus), and implement the `handleCodeReview` function. The handler safely extracts prompt arguments and dynamically constructs the LLM instructions based on the 'focus' parameter, showcasing a complete prompt-driven workflow.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_1

LANGUAGE: go
CODE:
```
import (
    "context"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    s := server.NewMCPServer("Code Assistant", "1.0.0",
        server.WithPromptCapabilities(true),
    )

    // Code review prompt
    codeReviewPrompt := mcp.NewPrompt("code_review",
        mcp.WithPromptDescription("Review code for best practices, bugs, and improvements"),
        mcp.WithPromptArgument("code",
            mcp.Required(),
            mcp.Description("The code to review"),
        ),
        mcp.WithPromptArgument("language",
            mcp.Description("Programming language (auto-detected if not specified)"),
        ),
        mcp.WithPromptArgument("focus",
            mcp.Description("Specific areas to focus on"),
            mcp.Enum("security", "performance", "readability", "best-practices", "all"),
            mcp.Default("all"),
        ),
    )

    s.AddPrompt(codeReviewPrompt, handleCodeReview)
    server.ServeStdio(s)
}

func handleCodeReview(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    // Extract arguments safely
    args := req.Params.Arguments
    if args == nil {
        return nil, fmt.Errorf("missing required arguments")
    }
    
    code, ok := args["code"].(string)
    if !ok {
        return nil, fmt.Errorf("code argument is required and must be a string")
    }
    
    language := getStringArg(args, "language", "auto-detect")
    focus := getStringArg(args, "focus", "all")

    // Build the prompt based on focus area
    var instructions string
    switch focus {
    case "security":
        instructions = "Focus specifically on security vulnerabilities, input validation, and potential attack vectors."
    case "performance":
        instructions = "Focus on performance optimizations, algorithmic efficiency, and resource usage."
    case "readability":
        instructions = "Focus on code clarity, naming conventions, and maintainability."
    case "best-practices":
        instructions = "Focus on language-specific best practices and design patterns."
    default:
        instructions = "Provide a comprehensive review covering security, performance, readability, and best practices."
    }

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("Code review for %s code", language),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(fmt.Sprintf(
                    "Please review the following %s code:\n\n%s\n\nInstructions: %s\n\nPlease provide:\n1. Overall assessment\n2. Specific issues found\n3. Suggested improvements\n4. Best practice recommendations\n\nCode:\n
```
```

----------------------------------------

TITLE: Implement Process Management for Go MCP Server
DESCRIPTION: This Go code snippet shows how to implement robust process management for an MCP server. It includes graceful panic recovery using `defer` and `recover`, integrates built-in server recovery, sets up signal handling for graceful shutdowns, and implements retry logic for server startup.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_10

LANGUAGE: go
CODE:
```
func main() {
    // Handle panics gracefully
    defer func() {
        if r := recover(); r != nil {
            logError(fmt.Sprintf("Server panic: %v", r))
            os.Exit(1)
        }
    }()

    s := server.NewMCPServer("Robust Server", "1.0.0",
        server.WithRecovery(), // Built-in panic recovery
    )

    // Setup signal handling
    setupSignalHandling()

    // Start server with retry logic
    for attempts := 0; attempts < 3; attempts++ {
        if err := server.ServeStdio(s); err != nil {
            logError(fmt.Sprintf("Server attempt %d failed: %v", attempts+1, err))
            if attempts == 2 {
                os.Exit(1)
            }
            time.Sleep(time.Second * time.Duration(attempts+1))
        } else {
            break
        }
    }
}

func setupSignalHandling() {
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        sig := <-c
        logToFile(fmt.Sprintf("Received signal: %v", sig))
        os.Exit(0)
    }()
}
```

----------------------------------------

TITLE: Manage MCP Go Client Lifecycle and Graceful Shutdown
DESCRIPTION: This Go code defines a `ManagedClient` struct and its associated methods for managing the lifecycle of an MCP client. It includes a constructor `NewManagedClient` to create different client types (stdio, streamablehttp, sse), a `WaitForReady` method to await background initialization, and a `Close` method to gracefully shut down the client by canceling its context and closing the underlying connection.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_6

LANGUAGE: Go
CODE:
```
type ManagedClient struct {
    client client.Client
    ctx    context.Context
    cancel context.CancelFunc
    done   chan struct{}
}

func NewManagedClient(clientType, address string) (*ManagedClient, error) {
    var c client.Client
    var err error

    switch clientType {
    case "stdio":
        c, err = client.NewSSEMCPClient("server-command")
    case "streamablehttp":
        c = client.NewStreamableHttpClient(address)
    case "sse":
        c = client.NewSSEMCPClient(address)
    default:
        return nil, fmt.Errorf("unknown client type: %s", clientType)
    }

    if err != nil {
        return nil, err
    }

    ctx, cancel := context.WithCancel(context.Background())

    mc := &ManagedClient{
        client: c,
        ctx:    ctx,
        cancel: cancel,
        done:   make(chan struct{}),
    }

    // Initialize in background
    go func() {
        defer close(mc.done)
        if err := c.Initialize(ctx); err != nil {
            log.Printf("Client initialization failed: %v", err)
        }
    }()

    return mc, nil
}

func (mc *ManagedClient) WaitForReady(timeout time.Duration) error {
    select {
    case <-mc.done:
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("client initialization timeout")
    case <-mc.ctx.Done():
        return mc.ctx.Err()
    }
}

func (mc *ManagedClient) Close() error {
    mc.cancel()
    
    // Wait for initialization to complete or timeout
    select {
    case <-mc.done:
    case <-time.After(5 * time.Second):
        log.Println("Timeout waiting for client shutdown")
    }

    return mc.client.Close()
}
```

----------------------------------------

TITLE: Handle Role-Based Prompts in Go
DESCRIPTION: The `handleRoleBasedPrompt` function dynamically generates system and user messages based on specified expertise, task, and an optional context. It allows defining a system's persona (e.g., software engineer, data scientist, product manager) and then appends user messages for the task and context, returning a `GetPromptResult` for flexible prompt generation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
func handleRoleBasedPrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    expertise := req.Params.Arguments["expertise"].(string)
    task := req.Params.Arguments["task"].(string)
    context := getStringArg(req.Params.Arguments, "context", "")

    // Define system message based on expertise
    var systemMessage string
    switch expertise {
    case "software_engineer":
        systemMessage = "You are an experienced software engineer with expertise in system design, code quality, and best practices."
    case "data_scientist":
        systemMessage = "You are a data scientist with expertise in statistical analysis, machine learning, and data visualization."
    case "product_manager":
        systemMessage = "You are a product manager with expertise in user experience, market analysis, and feature prioritization."
    default:
        systemMessage = fmt.Sprintf("You are an expert in %s.", expertise)
    }

    messages := []mcp.PromptMessage{
        {
            Role: "system",
            Content: mcp.NewTextContent(systemMessage),
        },
    }

    // Add context if provided
    if context != "" {
        messages = append(messages, mcp.PromptMessage{
            Role: "user",
            Content: mcp.NewTextContent(fmt.Sprintf("Context: %s", context)),
        })
    }

    // Add the main task
    messages = append(messages, mcp.PromptMessage{
        Role: "user",
        Content: mcp.NewTextContent(task),
    })

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("%s task", strings.Title(expertise)),
        Messages:    messages,
    }, nil
}
```

----------------------------------------

TITLE: Go: Efficient Resource Usage with Connection Pooling and Caching
DESCRIPTION: This Go snippet demonstrates two key resource efficiency patterns: database connection pooling using `sql.DB` to manage concurrent database access with configured max open/idle connections and lifetime, and an in-memory file cache with a time-based eviction policy and `sync.RWMutex` for concurrent safe read/write access.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_11

LANGUAGE: go
CODE:
```
// Use connection pooling for database tools
var dbPool *sql.DB

func init() {
    var err error
    dbPool, err = sql.Open("sqlite3", "data.db")
    if err != nil {
        log.Fatal(err)
    }
    
    dbPool.SetMaxOpenConns(10)
    dbPool.SetMaxIdleConns(5)
    dbPool.SetConnMaxLifetime(time.Hour)
}

// Cache frequently accessed data
var fileCache = make(map[string]cacheEntry)
var cacheMutex sync.RWMutex

type cacheEntry struct {
    content   string
    timestamp time.Time
}

func getCachedFile(path string) (string, bool) {
    cacheMutex.RLock()
    defer cacheMutex.RUnlock()
    
    entry, exists := fileCache[path]
    if !exists || time.Since(entry.timestamp) > 5*time.Minute {
        return "", false;
    }
    
    return entry.content, true;
}
```

----------------------------------------

TITLE: Implement Custom Business Logic Hooks in Go
DESCRIPTION: This Go snippet demonstrates `BusinessHooks` for integrating custom logic into application events. It includes examples for auditing sensitive tool calls, sending alerts on errors or slow executions, initializing user-specific resources at session start, and cleaning up/logging at session end. This pattern allows for flexible extension of core application behavior.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
type BusinessHooks struct {
    auditLogger AuditLogger
    notifier    Notifier
}

func (h *BusinessHooks) OnToolCall(sessionID, toolName string, duration time.Duration, err error) {
    // Audit sensitive operations
    if isSensitiveTool(toolName) {
        h.auditLogger.LogToolCall(sessionID, toolName, err)
    }
    
    // Alert on errors
    if err != nil {
        h.notifier.SendAlert(fmt.Sprintf("Tool %s failed for session %s: %v", 
            toolName, sessionID, err))
    }
    
    // Monitor performance
    if duration > 30*time.Second {
        h.notifier.SendAlert(fmt.Sprintf("Slow tool execution: %s took %v", 
            toolName, duration))
    }
}

func (h *BusinessHooks) OnSessionStart(sessionID string) {
    // Initialize user-specific resources
    h.initializeUserResources(sessionID)
    
    // Send welcome notification
    h.notifier.SendWelcome(sessionID)
}

func (h *BusinessHooks) OnSessionEnd(sessionID string) {
    // Cleanup user resources
    h.cleanupUserResources(sessionID)
    
    // Log session summary
    h.auditLogger.LogSessionEnd(sessionID)
}
```

----------------------------------------

TITLE: Go: Implement StreamableHTTP Server Middleware
DESCRIPTION: This snippet demonstrates how to add custom middleware to an MCP server for various functionalities. It includes examples for an authentication middleware that validates a token and adds user information to the context, a rate limiting middleware that checks client IP, and a caching middleware that serves cached resources and stores successful results.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
func addStreamableHTTPMiddleware(s *server.MCPServer) {
    // Authentication middleware
    s.AddToolMiddleware(func(next server.ToolHandler) server.ToolHandler {
        return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            // Extract and validate auth token
            token := extractAuthToken(ctx)
            if token == "" {
                return nil, fmt.Errorf("authentication required")
            }
            
            user, err := validateToken(token)
            if err != nil {
                return nil, fmt.Errorf("invalid token: %w", err)
            }
            
            // Add user to context
            ctx = context.WithValue(ctx, "user", user)
            return next(ctx, req)
        }
    })

    // Rate limiting middleware
    s.AddToolMiddleware(func(next server.ToolHandler) server.ToolHandler {
        return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            clientIP := getClientIP(ctx)
            if !rateLimiter.Allow(clientIP) {
                return nil, fmt.Errorf("rate limit exceeded")
            }
            return next(ctx, req)
        }
    })

    // Caching middleware
    s.AddResourceMiddleware(func(next server.ResourceHandler) server.ResourceHandler {
        return func(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
            // Check cache first
            if cached := getFromCache(req.Params.URI); cached != nil {
                return cached, nil
            }
            
            result, err := next(ctx, req)
            if err == nil {
                // Cache successful results
                setCache(req.Params.URI, result, 5*time.Minute)
            }
            
            return result, err
        }
    })
}
```

----------------------------------------

TITLE: Go Resilient SSE Client Implementation
DESCRIPTION: This Go code defines a `ResilientSSEClient` struct that manages a Server-Sent Events (SSE) connection with automatic reconnection capabilities. It includes methods for initializing the client, setting custom headers, handling connection and reconnection logic, making API calls (`CallTool`), subscribing to events (`Subscribe`), and gracefully closing the connection. The client uses a mutex for thread-safe access to its internal state and a `reconnectLoop` goroutine to manage retries upon connection loss.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
type ResilientSSEClient struct {
    baseURL     string
    headers     map[string]string
    client      *client.SSEClient
    ctx         context.Context
    cancel      context.CancelFunc
    reconnectCh chan struct{}
    mutex       sync.RWMutex
}

func NewResilientSSEClient(baseURL string) *ResilientSSEClient {
    ctx, cancel := context.WithCancel(context.Background())

    rsc := &ResilientSSEClient{
        baseURL:     baseURL,
        headers:     make(map[string]string),
        ctx:         ctx,
        cancel:      cancel,
        reconnectCh: make(chan struct{}, 1),
    }

    go rsc.reconnectLoop()
    return rsc
}

func (rsc *ResilientSSEClient) SetHeader(key, value string) {
    rsc.mutex.Lock()
    defer rsc.mutex.Unlock()
    rsc.headers[key] = value
}

func (rsc *ResilientSSEClient) connect() error {
    rsc.mutex.Lock()
    defer rsc.mutex.Unlock()

    if rsc.client != nil {
        rsc.client.Close()
    }

    client := client.NewSSEClient(rsc.baseURL)
    
    // Set headers
    for key, value := range rsc.headers {
        client.SetHeader(key, value)
    }

    if err := client.Initialize(rsc.ctx); err != nil {
        return err
    }

    rsc.client = client
    return nil
}

func (rsc *ResilientSSEClient) reconnectLoop() {
    for {
        select {
        case <-rsc.ctx.Done():
            return
        case <-rsc.reconnectCh:
            log.Println("Reconnecting SSE client...")
            
            for attempt := 1; attempt <= 5; attempt++ {
                if err := rsc.connect(); err != nil {
                    log.Printf("Reconnection attempt %d failed: %v", attempt, err)
                    
                    backoff := time.Duration(attempt) * time.Second
                    select {
                    case <-time.After(backoff):
                    case <-rsc.ctx.Done():
                        return
                    }
                } else {
                    log.Println("Reconnected successfully")
                    break
                }
            }
        }
    }
}

func (rsc *ResilientSSEClient) CallTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    rsc.mutex.RLock()
    client := rsc.client
    rsc.mutex.RUnlock()

    if client == nil {
        return nil, fmt.Errorf("client not connected")
    }

    result, err := client.CallTool(ctx, req)
    if err != nil && isConnectionError(err) {
        // Trigger reconnection
        select {
        case rsc.reconnectCh <- struct{}{}:
        default:
        }
        return nil, fmt.Errorf("connection error: %w", err)
    }

    return result, err
}

func (rsc *ResilientSSEClient) Subscribe(ctx context.Context) (<-chan mcp.Notification, error) {
    rsc.mutex.RLock()
    client := rsc.client
    rsc.mutex.RUnlock()

    if client == nil {
        return nil, fmt.Errorf("client not connected")
    }

    return client.Subscribe(ctx)
}

func (rsc *ResilientSSEClient) Close() error {
    rsc.cancel()
    
    rsc.mutex.Lock()
    defer rsc.mutex.Unlock()
    
    if rsc.client != nil {
        return rsc.client.Close()
    }
    
    return nil
}

// Helper function to check if an error is a connection error
func isConnectionError(err error) bool {
    return errors.Is(err, ErrConnectionLost) ||
           errors.Is(err, ErrConnectionFailed)
}
```

----------------------------------------

TITLE: Configure Go Server with Security and Recovery Middleware
DESCRIPTION: This Go snippet demonstrates how to initialize an `MCPServer` with custom middleware for enhanced security and robustness. It shows the application of `authMiddleware`, `rateLimitMiddleware`, and a `WithRecovery` option to handle panics gracefully.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/index.mdx#_snippet_3

LANGUAGE: Go
CODE:
```
s := server.NewMCPServer("Secure Server", "1.0.0",
    server.WithToolMiddleware(authMiddleware),
    server.WithToolMiddleware(rateLimitMiddleware),
    server.WithRecovery(),
)
```

----------------------------------------

TITLE: Complete MCP Server Example in Go
DESCRIPTION: This comprehensive Go example demonstrates how to set up an MCP server, add tools, resources, and prompts, and handle incoming requests for each. It showcases the core functionalities of the `mcp-go` library for interacting with LLM clients, including server initialization with capabilities, tool definition, resource exposure, and prompt creation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/index.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

var start time.Time

func main() {
    start = time.Now()
    // Create server with capabilities
    s := server.NewMCPServer(
        "Demo Server",
        "1.0.0",
        server.WithToolCapabilities(true),
        server.WithResourceCapabilities(false, true),
        server.WithPromptCapabilities(true),
    )

    // Add a tool
    s.AddTool(
        mcp.NewTool("get_time",
            mcp.WithDescription("Get the current time"),
            mcp.WithString("format", 
                mcp.Description("Time format (RFC3339, Unix, etc.)"),
                mcp.DefaultString("RFC3339"),
            ),
        ),
        handleGetTime,
    )

    // Add a resource
    s.AddResource(
        mcp.NewResource(
            "config://server",
            "Server Configuration",
            mcp.WithResourceDescription("Current server configuration"),
            mcp.WithMIMEType("application/json"),
        ),
        handleConfig,
    )

    // Add a prompt
    s.AddPrompt(
        mcp.NewPrompt("analyze_logs",
            mcp.WithPromptDescription("Analyze server logs for issues"),
            mcp.WithArgument("log_level",
                mcp.ArgumentDescription("Minimum log level to analyze"),
            ),
        ),
        handleAnalyzeLogs,
    )

    // Start the server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

func handleGetTime(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    format := req.GetString("format", "RFC3339")
    
    var timeStr string
    switch format {
    case "Unix":
        timeStr = fmt.Sprintf("%d", time.Now().Unix())
    default:
        timeStr = time.Now().Format(time.RFC3339)
    }
    
    return mcp.NewToolResultText(timeStr), nil
}

func handleConfig(ctx context.Context, req mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    config := map[string]interface{}{
        "name": "Demo Server",
        "version": "1.0.0",
        "uptime": time.Since(start).String(),
    }
    
    configJSON, err := json.Marshal(config)
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: "application/json",
            Text:     string(configJSON),
        },
    },
}

func handleAnalyzeLogs(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    logLevel := "error" // default value
    if args := req.Params.Arguments; args != nil {
        if level, ok := args["log_level"].(string); ok {
            logLevel = level
        }
    }
    
    return &mcp.GetPromptResult{
        Description: "Analyze server logs for potential issues",
        Messages: []mcp.PromptMessage{
            {
                Role: mcp.RoleUser,
                Content: mcp.NewTextContent(fmt.Sprintf(
                    "Please analyze the server logs for entries at %s level or higher. "+
                    "Look for patterns, errors, and potential issues that need attention.",
                    logLevel,
                )),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Implementing Stateless Session Management in Go
DESCRIPTION: Demonstrates a recommended stateless design pattern for handling tool calls in an MCP server. It shows how to extract all necessary information from the request context and parameters, process it independently without relying on server-side state, and use external storage (like Redis) for persistence of user preferences.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_11

LANGUAGE: go
CODE:
```
// Each request is independent
func handleStatelessTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Extract all needed information from request
    userID := extractUserFromToken(ctx)
    params := req.Params.Arguments
    
    // Process without relying on server state
    result, err := processRequest(userID, params)
    if err != nil {
        return nil, err
    }
    
    return mcp.NewToolResultJSON(result), nil
}

// Use external storage for persistence
func getUserPreferences(userID string) (map[string]interface{}, error) {
    // Load from database, cache, etc.
    return loadFromRedis(fmt.Sprintf("user:%s:prefs", userID))
}
```

----------------------------------------

TITLE: Integrate Multiple Resources for Dynamic Prompts (Go)
DESCRIPTION: The `handleDynamicResourcePrompt` Go function is designed to handle prompt requests involving multiple external resources. It iterates through a list of resource URIs, fetches each document, and then dynamically builds a comprehensive prompt. This function supports different prompt types, such as 'compare' (comparing multiple documents) or 'synthesize' (synthesizing information from multiple sources), providing a flexible way to interact with AI models based on diverse inputs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
func handleDynamicResourcePrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    resourceURIs := req.Params.Arguments["resource_uris"].([]interface{})
    promptType := getStringArg(req.Params.Arguments, "prompt_type", "compare")

    // Fetch all resources
    var resources []ResourceData
    for _, uri := range resourceURIs {
        if uriStr, ok := uri.(string); ok {
            resource, err := fetchResource(ctx, uriStr)
            if err != nil {
                return nil, fmt.Errorf("failed to fetch resource %s: %w", uriStr, err)
            }
            resources = append(resources, resource)
        }
    }

    // Build prompt based on type and resources
    var content strings.Builder
    
    switch promptType {
    case "compare":
        content.WriteString("Please compare and contrast the following documents:\n\n")
        for i, resource := range resources {
            content.WriteString(fmt.Sprintf("Document %d (%s):\n%s\n\n", i+1, resource.URI, resource.Content))
        }
        content.WriteString("Please provide:\n1. Key similarities\n2. Important differences\n3. Overall assessment")
        
    case "synthesize":
        content.WriteString("Please synthesize information from the following sources:\n\n")
        for i, resource := range resources {
            content.WriteString(fmt.Sprintf("Source %d (%s):\n%s\n\n", i+1, resource.URI, resource.Content))
        }
        content.WriteString("Please create a unified analysis that incorporates insights from all sources.")
    }

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("%s multiple resources", strings.Title(promptType)),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(content.String())
            }
        }
    }, nil
}
```

----------------------------------------

TITLE: Exposing Database Records as MCP-Go Resources
DESCRIPTION: Demonstrates how to register an MCP-Go resource that dynamically exposes database records. It includes URI parsing, table name validation for security, querying a SQL database, and marshaling results to JSON. The resource uses a 'db://{table}/{id}' URI pattern to identify specific records.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_4

LANGUAGE: Go
CODE:
```
import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

// Database table resource
s.AddResource(
    mcp.NewResource(
        "db://{table}/{id}",
        "Database Record",
        mcp.WithResourceDescription("Access database records by table and ID"),
        mcp.WithMIMEType("application/json"),
    ),
    handleDatabaseRecord,
)

func handleDatabaseRecord(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    table, id := parseDBURI(req.Params.URI) // "db://users/123" -> "users", "123"
    
    // Validate table name for security
    allowedTables := map[string]bool{
        "users":    true,
        "products": true,
        "orders":   true,
    }
    
    if !allowedTables[table] {
        return nil, fmt.Errorf("table not accessible: %s", table)
    }

    // Query database
    query := fmt.Sprintf("SELECT * FROM %s WHERE id = ?", table)
    row := db.QueryRowContext(ctx, query, id)
    
    var data map[string]interface{}
    if err := scanRowToMap(row, &data); err != nil {
        return nil, fmt.Errorf("record not found: %w", err)
    }

    jsonData, err := json.Marshal(data);
    if err != nil {
        return nil, err
    }
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            mcp.TextResourceContent{
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(jsonData),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Go: Embedding MCP Server and Client in an Application
DESCRIPTION: This comprehensive example demonstrates how to embed an MCP server and an in-process client within a Go application. It illustrates the `Application` structure, `NewApplication` constructor for setup, `addApplicationTools` for registering custom tools like `get_app_status` and `update_config`, and `ProcessWithMCP` for internal tool invocation. The `main` function provides a complete usage flow, including client initialization and calling application-specific logic through MCP.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/inprocess.mdx#_snippet_1

LANGUAGE: Go
CODE:
```
// Embedded MCP server in a larger application
type Application struct {
    mcpServer *server.MCPServer
    mcpClient *client.InProcessClient
    config    *Config
}

func NewApplication(config *Config) *Application {
    app := &Application{
        config: config,
    }

    // Create embedded MCP server
    app.mcpServer = server.NewMCPServer("Embedded Server", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // Add application-specific tools
    app.addApplicationTools()

    // Create in-process client for internal use
    var err error
    app.mcpClient, err = client.NewInProcessClient(app.mcpServer)
    if err != nil {
        panic(err)
    }

    return app
}

type Config struct {
    AppName string
    Debug   bool
}

func (app *Application) addApplicationTools() {
    // Application status tool
    app.mcpServer.AddTool(
        mcp.NewTool("get_app_status",
            mcp.WithDescription("Get current application status"),
        ),
        func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            return mcp.NewToolResultText(fmt.Sprintf(`{"app_name":"%s","debug":%t,"status":"running"}`, 
                app.config.AppName, app.config.Debug)), nil
        },
    )

    // Configuration tool
    app.mcpServer.AddTool(
        mcp.NewTool("update_config",
            mcp.WithDescription("Update application configuration"),
            mcp.WithString("key", mcp.Required()),
            mcp.WithString("value", mcp.Required()),
        ),
        func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            key := req.GetString("key", "")
            value := req.GetString("value", "")

            // Update configuration based on key
            switch key {
            case "debug":
                app.config.Debug = value == "true"
            case "app_name":
                app.config.AppName = value
            default:
                return mcp.NewToolResultError(fmt.Sprintf("unknown config key: %s", key)), nil
            }

            return mcp.NewToolResultText(fmt.Sprintf("Updated %s to %s", key, value)), nil
        },
    )
}

func (app *Application) ProcessWithMCP(ctx context.Context, operation string) (interface{}, error) {
    // Use MCP tools internally for processing
    result, err := app.mcpClient.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolParams{
            Name: "calculate",
            Arguments: map[string]interface{}{
                "operation": operation,
                "x":         10.0,
                "y":         5.0,
            },
        },
    })
    if err != nil {
        return nil, err
    }

    // Extract text from the first content item
    if len(result.Content) > 0 {
        if textContent, ok := mcp.AsTextContent(result.Content[0]); ok {
            return textContent.Text, nil
        }
    }
    
    return "no result", nil
}

// Usage example
func main() {
    config := &Config{
        AppName: "My App",
        Debug:   true,
    }

    app := NewApplication(config)
    ctx := context.Background()

    // Initialize the embedded MCP client
    _, err := app.mcpClient.Initialize(ctx, mcp.InitializeRequest{
        Params: mcp.InitializeRequestParams{
            ProtocolVersion: "2024-11-05",
            Capabilities: mcp.ClientCapabilities{
                Tools: &mcp.ToolsCapability{},
            },
            ClientInfo: mcp.Implementation{
                Name:    "embedded-client",
                Version: "1.0.0",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // Use MCP functionality within the application
    result, err := app.ProcessWithMCP(ctx, "add")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Application result: %v\n", result)
}
```

----------------------------------------

TITLE: Go: Configure Advanced StreamableHTTP MCP Server
DESCRIPTION: This code snippet illustrates how to set up an advanced MCP server using `server.NewMCPServer` with various capabilities enabled (resources, prompts, tools, logging). It then configures and starts a `StreamableHTTPServer` with a custom endpoint path, heartbeat interval, and state management. Placeholder functions for adding different types of tools and logging tool/resource interactions are also included.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_4

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("Advanced StreamableHTTP Server", "1.0.0",
        server.WithResourceCapabilities(true, true),
        server.WithPromptCapabilities(true),
        server.WithToolCapabilities(true),
        server.WithLogging(),
    )

    // Add comprehensive tools and resources
    addCRUDTools(s)
    addBatchTools(s)
    addAnalyticsTools(s)

    log.Println("Starting advanced StreamableHTTP server on :8080")
    httpServer := server.NewStreamableHTTPServer(s,
        server.WithEndpointPath("/api/v1/mcp"),
        server.WithHeartbeatInterval(30*time.Second),
        server.WithStateLess(false),
    )
    
    if err := httpServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}

// Helper functions for the advanced example
func addCRUDTools(s *server.MCPServer) {
    // Placeholder implementation - would add CRUD tools
}

func addBatchTools(s *server.MCPServer) {
    // Placeholder implementation - would add batch processing tools
}

func addAnalyticsTools(s *server.MCPServer) {
    // Placeholder implementation - would add analytics tools
}

func logToolCall(sessionID, toolName string, duration time.Duration, err error) {
    // Placeholder implementation
    if err != nil {
        log.Printf("Tool %s failed: %v", toolName, err)
    } else {
        log.Printf("Tool %s completed in %v", toolName, duration)
    }
}

func logResourceRead(sessionID, uri string, duration time.Duration, err error) {
    // Placeholder implementation
    if err != nil {
        log.Printf("Resource read %s failed: %v", uri, err)
    } else {
        log.Printf("Resource read %s completed in %v", uri, duration)
    }
}
```

----------------------------------------

TITLE: Implement Go Retry Logic with Exponential Backoff
DESCRIPTION: This Go code defines a flexible retry mechanism with exponential backoff. It includes a RetryConfig struct for customization, a DefaultRetryConfig function, an IsRetryable method to check error types, and a generic WithRetry function to wrap any operation. It also provides a usage example for calling a tool with retry.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
type RetryConfig struct {
    MaxRetries      int
    InitialDelay    time.Duration
    MaxDelay        time.Duration
    BackoffFactor   float64
    RetryableErrors []error
}

func DefaultRetryConfig() RetryConfig {
    return RetryConfig{
        MaxRetries:    3,
        InitialDelay:  1 * time.Second,
        MaxDelay:      30 * time.Second,
        BackoffFactor: 2.0,
        RetryableErrors: []error{
            client.ErrConnectionLost,
            client.ErrTimeout,
            client.ErrConnectionFailed,
        },
    }
}

func (rc RetryConfig) IsRetryable(err error) bool {
    for _, retryableErr := range rc.RetryableErrors {
        if errors.Is(err, retryableErr) {
            return true
        }
    }
    return false
}

func WithRetry[T any](ctx context.Context, config RetryConfig, operation func() (T, error)) (T, error) {
    var lastErr error
    var zero T

    for attempt := 0; attempt <= config.MaxRetries; attempt++ {
        result, err := operation()
        if err == nil {
            return result, nil
        }

        lastErr = err

        // Don't retry non-retryable errors
        if !config.IsRetryable(err) {
            break
        }

        // Don't retry on last attempt
        if attempt == config.MaxRetries {
            break
        }

        // Calculate delay with exponential backoff
        delay := time.Duration(float64(config.InitialDelay) * math.Pow(config.BackoffFactor, float64(attempt)))
        if delay > config.MaxDelay {
            delay = config.MaxDelay
        }

        log.Printf("Attempt %d failed, retrying in %v: %v", attempt+1, delay, err)

        // Wait with context cancellation support
        select {
        case <-time.After(delay):
        case <-ctx.Done():
            return zero, ctx.Err()
        }
    }

    return zero, fmt.Errorf("failed after %d attempts: %w", config.MaxRetries+1, lastErr)
}

// Usage example
func callToolWithRetry(ctx context.Context, c client.Client, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    config := DefaultRetryConfig()
    
    return WithRetry(ctx, config, func() (*mcp.CallToolResult, error) {
        return c.CallTool(ctx, req)
    })
}
```

----------------------------------------

TITLE: Handle Data Analysis Prompt in Go
DESCRIPTION: This Go function `handleDataAnalysis` constructs a detailed prompt for AI-driven data analysis. It dynamically adjusts the analysis instructions based on `analysis_type` (exploratory, predictive, diagnostic) and `focus_areas`, then formats the dataset information into a user message for an AI model. It requires a dataset URI and fetches the dataset before generating the prompt.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_2

LANGUAGE: Go
CODE:
```
func handleDataAnalysis(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    datasetURI := req.Params.Arguments["dataset_uri"].(string)
    analysisType := getStringArg(req.Params.Arguments, "analysis_type", "exploratory")
    focusAreas := getStringSliceArg(req.Params.Arguments, "focus_areas", []string{})

    // Fetch the dataset (this would typically read from a resource)
    dataset, err := fetchDataset(ctx, datasetURI)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch dataset: %w", err)
    }

    // Build analysis instructions
    var instructions strings.Builder
    instructions.WriteString("Please analyze the provided dataset. ")

    switch analysisType {
    case "exploratory":
        instructions.WriteString("Perform exploratory data analysis including summary statistics, distributions, and patterns.")
    case "predictive":
        instructions.WriteString("Focus on predictive modeling opportunities and feature relationships.")
    case "diagnostic":
        instructions.WriteString("Identify data quality issues, outliers, and potential problems.")
    }

    if len(focusAreas) > 0 {
        instructions.WriteString(fmt.Sprintf(" Pay special attention to: %s.", strings.Join(focusAreas, ", ")))
    }

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("%s analysis of dataset", strings.Title(analysisType)),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(fmt.Sprintf(`%s

Dataset Information:
- Source: %s
- Records: %d
- Columns: %s

Dataset Preview:
%s

Please provide a comprehensive analysis including:
1. Data overview and quality assessment
2. Key insights and patterns
3. Recommendations for further analysis
4. Potential issues or concerns`,
                    instructions.String(),
                    datasetURI,
                    dataset.RecordCount,
                    strings.Join(dataset.Columns, ", "),
                    dataset.Preview,
                )),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Create a Basic MCP Server with a Hello World Tool in Go
DESCRIPTION: Demonstrates how to set up a simple MCP server in Go, define a 'hello_world' tool with a string parameter, and implement its handler to return a greeting. The server is configured to serve via stdio.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_1

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "Demo 🚀",
        "1.0.0",
        server.WithToolCapabilities(false),
    )

    // Add tool
    tool := mcp.NewTool("hello_world",
        mcp.WithDescription("Say hello to someone"),
        mcp.WithString("name",
            mcp.Required(),
            mcp.Description("Name of the person to greet"),
        ),
    )

    // Add tool handler
    s.AddTool(tool, helloHandler)

    // Start the stdio server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    name, err := request.RequireString("name")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }

    return mcp.NewToolResultText(fmt.Sprintf("Hello, %s!", name)), nil
}
```

----------------------------------------

TITLE: Implement Retry Logic for MCP-Go Tool Calls
DESCRIPTION: This function provides a retry mechanism with exponential backoff for `mcp-go` tool calls. It retries failed operations up to a maximum number of attempts, skipping retries for non-recoverable errors like invalid arguments or missing tools, and respects context cancellation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_7

LANGUAGE: Go
CODE:
```
func callToolWithRetry(ctx context.Context, c client.Client, req mcp.CallToolRequest, maxRetries int) (*mcp.CallToolResult, error) {
    var lastErr error

    for attempt := 0; attempt <= maxRetries; attempt++ {
        result, err := c.CallTool(ctx, req)
        if err == nil {
            return result, nil
        }

        lastErr = err

        // Don't retry certain errors
        if errors.Is(err, client.ErrInvalidArguments) ||
           errors.Is(err, client.ErrToolNotFound) {
            break
        }

        // Exponential backoff
        if attempt < maxRetries {
            backoff := time.Duration(1<<attempt) * time.Second
            log.Printf("Attempt %d failed, retrying in %v: %v", attempt+1, backoff, err)
            
            select {
            case <-time.After(backoff):
            case <-ctx.Done():
                return nil, ctx.Err()
            }
        }
    }

    return nil, fmt.Errorf("failed after %d attempts: %w", maxRetries+1, lastErr)
}
```

----------------------------------------

TITLE: Go Multi-Server Client for Distributed Tool Calls
DESCRIPTION: This Go code defines a `MultiServerClient` struct and its associated methods. It allows for managing connections to multiple servers, supporting different client types like HTTP and SSE. The client provides functionality to add new servers, initialize their respective clients, call specific tools on a designated server, and retrieve a consolidated list of all tools available across all connected servers, ensuring thread-safe operations using a mutex.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
type MultiServerClient struct {
    clients map[string]client.Client
    mutex   sync.RWMutex
}

func NewMultiServerClient() *MultiServerClient {
    return &MultiServerClient{
        clients: make(map[string]client.Client),
    }
}

func (msc *MultiServerClient) AddServer(name, address string, clientType string) error {
    msc.mutex.Lock()
    defer msc.mutex.Unlock()

    var c client.Client
    var err error

    switch clientType {
    case "http":
        c = client.NewStreamableHttpClient(address)
    case "sse":
        c = client.NewSSEMCPClient(address)
    default:
        return fmt.Errorf("unsupported client type: %s", clientType)
    }

    ctx := context.Background()
    if err := c.Initialize(ctx); err != nil {
        return fmt.Errorf("failed to initialize client for %s: %w", name, err)
    }

    msc.clients[name] = c
    return nil
}

func (msc *MultiServerClient) CallTool(ctx context.Context, serverName, toolName string, args map[string]interface{}) (*mcp.CallToolResult, error) {
    msc.mutex.RLock()
    c, exists := msc.clients[serverName]
    msc.mutex.RUnlock()

    if !exists {
        return nil, fmt.Errorf("server not found: %s", serverName)
    }

    return c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name:      toolName,
            Arguments: args,
        },
    })
}

func (msc *MultiServerClient) GetAllTools(ctx context.Context) (map[string][]mcp.Tool, error) {
    msc.mutex.RLock()
    defer msc.mutex.RUnlock()

    allTools := make(map[string][]mcp.Tool)

    for serverName, c := range msc.clients {
        tools, err := c.ListTools(ctx)
        if err != nil {
            return nil, fmt.Errorf("failed to get tools from %s: %w", serverName, err)
        }
        allTools[serverName] = tools.Tools
    }

    return allTools, nil
}
```

----------------------------------------

TITLE: Manage Go Server Lifecycle with Hooks and Graceful Shutdown
DESCRIPTION: This Go example illustrates how to integrate lifecycle hooks for client sessions (register/unregister) and requests (before/error) into an MCP server. It also demonstrates implementing a graceful shutdown mechanism using OS signals to ensure proper resource cleanup upon termination.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_10

LANGUAGE: Go
CODE:
```
func main() {
    hooks := &server.Hooks{}
    
    // Add session lifecycle hooks
    hooks.AddOnRegisterSession(func(ctx context.Context, session server.ClientSession) {
        log.Printf("Client %s connected", session.ID())
    })
    
    hooks.AddOnUnregisterSession(func(ctx context.Context, session server.ClientSession) {
        log.Printf("Client %s disconnected", session.ID())
    })
    
    // Add request hooks
    hooks.AddBeforeAny(func(ctx context.Context, id any, method mcp.MCPMethod, message any) {
        log.Printf("Processing %s request", method)
    })
    
    hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
        log.Printf("Error in %s: %v", method, err)
    })
    
    s := server.NewMCPServer("Lifecycle Server", "1.0.0",
        server.WithHooks(hooks),
    )
    
    // Graceful shutdown
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-c
        log.Println("Shutting down server...")
        s.Shutdown()
    }()
    
    server.ServeStdio(s)
}
```

----------------------------------------

TITLE: Manage Go STDIO Client with Auto-Restart
DESCRIPTION: This Go code defines a `ManagedStdioClient` that wraps a `StdioClient` to provide robust process management, including automatic restarts upon process errors. It initializes, monitors, and allows calling tools on the managed process, ensuring resilience against failures.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_2

LANGUAGE: go
CODE:
```
type ManagedStdioClient struct {
    client      *client.StdioClient
    options     client.StdioOptions
    restartChan chan struct{}
    ctx         context.Context
    cancel      context.CancelFunc
    wg          sync.WaitGroup
}

func NewManagedStdioClient(options client.StdioOptions) (*ManagedStdioClient, error) {
    ctx, cancel := context.WithCancel(context.Background())

    msc := &ManagedStdioClient{
        options:     options,
        restartChan: make(chan struct{}, 1),
        ctx:         ctx,
        cancel:      cancel,
    }

    if err := msc.start(); err != nil {
        cancel()
        return nil, err
    }

    msc.wg.Add(1)
    go msc.monitorProcess()

    return msc, nil
}

func (msc *ManagedStdioClient) start() error {
    client, err := client.NewStdioClientWithOptions(msc.options)
    if err != nil {
        return err
    }

    if err := client.Initialize(msc.ctx); err != nil {
        client.Close()
        return err
    }

    msc.client = client
    return nil
}

func (msc *ManagedStdioClient) monitorProcess() {
    defer msc.wg.Done()

    for {
        select {
        case <-msc.ctx.Done():
            return
        case <-msc.restartChan:
            log.Println("Restarting STDIO client...")
            
            if msc.client != nil {
                msc.client.Close()
            }

            // Wait before restarting
            time.Sleep(1 * time.Second)

            if err := msc.start(); err != nil {
                log.Printf("Failed to restart client: %v", err)
                // Try again after delay
                time.Sleep(5 * time.Second)
                select {
                case msc.restartChan <- struct{}{}:
                default:
                }
            } else {
                log.Println("Client restarted successfully")
            }
        }
    }
}

func (msc *ManagedStdioClient) CallTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    if msc.client == nil {
        return nil, fmt.Errorf("client not available")
    }

    result, err := msc.client.CallTool(ctx, req)
    if err != nil && isProcessError(err) {
        // Trigger restart
        select {
        case msc.restartChan <- struct{}{}:
        default:
        }
        return nil, fmt.Errorf("process error, restarting: %w", err)
    }

    return result, err
}

func (msc *ManagedStdioClient) Close() error {
    msc.cancel()
    msc.wg.Wait()
    
    if msc.client != nil {
        return msc.client.Close()
    }
    
    return nil
}

func isProcessError(err error) bool {
    return errors.Is(err, ErrProcessExited) ||
           errors.Is(err, ErrBrokenPipe) ||
           errors.Is(err, ErrProcessTimeout)
}
```

----------------------------------------

TITLE: Go Client Error Handling with Recovery and Diagnostics
DESCRIPTION: This Go code demonstrates a comprehensive error handling strategy for client-server interactions, categorizing errors into connection, protocol, and operation-specific types. It includes logic for retrying operations on recoverable errors (e.g., connection loss, timeouts) and providing diagnostic information or suggestions for unrecoverable or user-fixable errors (e.g., tool not found, invalid arguments). Helper functions are provided for client reconnection, listing available tools, and displaying tool schemas.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_8

LANGUAGE: go
CODE:
```
func handleClientErrors(ctx context.Context, c client.Client) {
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "example_tool",
            Arguments: map[string]interface{}{
                "param": "value",
            },
        },
    })

    if err != nil {
        switch {
        // Connection errors - may be recoverable
        case errors.Is(err, client.ErrConnectionLost):
            log.Println("Connection lost, attempting reconnect...")
            if reconnectErr := reconnectClient(c); reconnectErr != nil {
                log.Printf("Reconnection failed: %v", reconnectErr)
                return
            }
            // Retry the operation
            return handleClientErrors(ctx, c)

        case errors.Is(err, client.ErrTimeout):
            log.Println("Operation timed out, retrying with longer timeout...")
            ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
            defer cancel()
            return handleClientErrors(ctx, c)

        // Protocol errors - usually not recoverable
        case errors.Is(err, client.ErrProtocolViolation):
            log.Printf("Protocol violation: %v", err)
            return

        case errors.Is(err, client.ErrUnsupportedVersion):
            log.Printf("Unsupported protocol version: %v", err)
            return

        // Operation errors - check and fix request
        case errors.Is(err, client.ErrToolNotFound):
            log.Printf("Tool not found: %v", err)
            // Maybe list available tools and suggest alternatives
            suggestAlternativeTools(ctx, c)
            return

        case errors.Is(err, client.ErrInvalidArguments):
            log.Printf("Invalid arguments: %v", err)
            // Maybe get tool schema and show required parameters
            showToolSchema(ctx, c, "example_tool")
            return

        case errors.Is(err, client.ErrPermissionDenied):
            log.Printf("Permission denied: %v", err)
            // Maybe prompt for authentication
            return

        // Unknown errors
        default:
            log.Printf("Unexpected error: %v", err)
            return
        }
    }

    // Process successful result
    log.Printf("Tool result: %+v", result)
}

func reconnectClient(c client.Client) error {
    // Close existing connection
    if err := c.Close(); err != nil {
        log.Printf("Error closing client: %v", err)
    }

    // Wait before reconnecting
    time.Sleep(1 * time.Second)

    // Reinitialize
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    return c.Initialize(ctx)
}

func suggestAlternativeTools(ctx context.Context, c client.Client) {
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Printf("Failed to list tools: %v", err)
        return
    }

    log.Println("Available tools:")
    for _, tool := range tools.Tools {
        log.Printf("- %s: %s", tool.Name, tool.Description)
    }
}

func showToolSchema(ctx context.Context, c client.Client, toolName string) {
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Printf("Failed to list tools: %v", err)
        return
    }

    for _, tool := range tools.Tools {
        if tool.Name == toolName {
            log.Printf("Tool schema for %s:", toolName)
            log.Printf("Description: %s", tool.Description)
            log.Printf("Input schema: %+v", tool.InputSchema)
            return
        }
    }

    log.Printf("Tool %s not found", toolName)
}
```

----------------------------------------

TITLE: Implement Session-Based Rate Limiting Middleware in Go
DESCRIPTION: This Go code implements a `RateLimitMiddleware` that applies rate limiting on a per-session basis using `golang.org/x/time/rate`. It prevents abuse by limiting the number of requests a session can make within a given time frame, returning an error if the limit is exceeded to protect server resources.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_6

LANGUAGE: go
CODE:
```
type RateLimitMiddleware struct {
    limiters map[string]*rate.Limiter
    mutex    sync.RWMutex
    rate     rate.Limit
    burst    int
}

func NewRateLimitMiddleware(requestsPerSecond float64, burst int) *RateLimitMiddleware {
    return &RateLimitMiddleware{
        limiters: make(map[string]*rate.Limiter),
        rate:     rate.Limit(requestsPerSecond),
        burst:    burst,
    }
}

func (m *RateLimitMiddleware) getLimiter(sessionID string) *rate.Limiter {
    m.mutex.RLock()
    limiter, exists := m.limiters[sessionID]
    m.mutex.RUnlock()
    
    if !exists {
        m.mutex.Lock()
        limiter = rate.NewLimiter(m.rate, m.burst)
        m.limiters[sessionID] = limiter
        m.mutex.Unlock()
    }
    
    return limiter
}

func (m *RateLimitMiddleware) ToolMiddleware(next server.ToolHandler) server.ToolHandler {
    return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        sessionID := server.GetSessionID(ctx)
        limiter := m.getLimiter(sessionID)
        
        if !limiter.Allow() {
            return nil, fmt.Errorf("rate limit exceeded for session %s", sessionID)
        }
        
        return next(ctx, req)
    }
}
```

----------------------------------------

TITLE: Implement Resource Caching in Go
DESCRIPTION: This Go code defines a ResourceCache struct that provides in-memory caching for mcp.ReadResourceResult objects. It uses a sync.RWMutex for thread-safe access and a configurable Time-To-Live (TTL) for cache entries, ensuring that stale data is not returned. The ReadResource method integrates caching logic, fetching from the server only if the resource is not found in the cache or has expired.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_4

LANGUAGE: go
CODE:
```
type ResourceCache struct {
    cache map[string]cacheEntry
    mutex sync.RWMutex
    ttl   time.Duration
}

type cacheEntry struct {
    result    *mcp.ReadResourceResult
    timestamp time.Time
}

func NewResourceCache(ttl time.Duration) *ResourceCache {
    return &ResourceCache{
        cache: make(map[string]cacheEntry),
        ttl:   ttl,
    }
}

func (rc *ResourceCache) Get(uri string) (*mcp.ReadResourceResult, bool) {
    rc.mutex.RLock()
    defer rc.mutex.RUnlock()

    entry, exists := rc.cache[uri]
    if !exists || time.Since(entry.timestamp) > rc.ttl {
        return nil, false
    }

    return entry.result, true
}

func (rc *ResourceCache) Set(uri string, result *mcp.ReadResourceResult) {
    rc.mutex.Lock()
    defer rc.mutex.Unlock()

    rc.cache[uri] = cacheEntry{
        result:    result,
        timestamp: time.Now(),
    }
}

func (rc *ResourceCache) ReadResource(ctx context.Context, c client.Client, uri string) (*mcp.ReadResourceResult, error) {
    // Check cache first
    if cached, found := rc.Get(uri); found {
        return cached, nil
    }

    // Read from server
    result, err := readResource(ctx, c, uri)
    if err != nil {
        return nil, err
    }

    // Cache the result
    rc.Set(uri, result)
    return result, nil
}
```

----------------------------------------

TITLE: Validate and Extract Parameters in MCP-Go Tools
DESCRIPTION: This Go function illustrates how to use MCP-Go's helper methods (RequireString, RequireFloat, GetBool) for type-safe extraction of required and optional parameters from a mcp.CallToolRequest. It also shows how to apply custom validation constraints (e.g., length, range) and return errors for invalid inputs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
func handleValidatedTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Required parameters with validation
    name, err := req.RequireString("name")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    age, err := req.RequireFloat("age")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    // Optional parameter with default
    enabled := req.GetBool("enabled", true)
    
    // Validate constraints
    if len(name) == 0 {
        return mcp.NewToolResultError("name cannot be empty"), nil
    }
    
    if age < 0 || age > 150 {
        return mcp.NewToolResultError("age must be between 0 and 150"), nil
    }
    
    // Process with validated parameters
    result := processUser(name, int(age), enabled)
    
    jsonData, err := json.Marshal(result)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}
```

----------------------------------------

TITLE: Embed Single Resource Data into Prompts (Go)
DESCRIPTION: This Go function, `handleResourceEmbeddedPrompt`, processes a prompt request by fetching a single document specified by a URI. It then dynamically constructs a prompt message, embedding the document's content along with instructions for a specific analysis type (e.g., summary, critique, questions, action items). The function returns a structured prompt result suitable for an AI model.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
func handleResourceEmbeddedPrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    documentURI := req.Params.Arguments["document_uri"].(string)
    analysisType := getStringArg(req.Params.Arguments, "analysis_type", "summary")

    // Fetch the document content
    document, err := fetchResource(ctx, documentURI)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch document: %w", err)
    }

    // Build analysis prompt with embedded content
    var instructions string
    switch analysisType {
    case "summary":
        instructions = "Please provide a concise summary of the key points in this document."
    case "critique":
        instructions = "Please provide a critical analysis of the arguments and evidence presented."
    case "questions":
        instructions = "Please generate thoughtful questions that this document raises or could be used to explore."
    case "action_items":
        instructions = "Please extract actionable items and recommendations from this document."
    }

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("Document %s", analysisType),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(fmt.Sprintf(`%s

Document: %s
Content:
---
%s
---

Please provide your analysis following the instructions above.`,
                    instructions,
                    documentURI,
                    document.Content,
                )),
            }
        }
    }, nil
}
```

----------------------------------------

TITLE: Integrate LLM Applications with MCP-Go Client
DESCRIPTION: This snippet illustrates how to integrate an LLM application with the `mcp-go` client. It shows how an `LLMApplication` can list available tools, send user queries to an LLM, execute tool calls suggested by the LLM, and feed tool results back to the LLM for continued conversation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
type LLMApplication struct {
    mcpClient client.Client
    llmClient LLMClient
}

func NewLLMApplication(mcpAddress string) (*LLMApplication, error) {
    mcpClient := client.NewStreamableHttpClient(mcpAddress)
    
    ctx := context.Background()
    if err := mcpClient.Initialize(ctx); err != nil {
        return nil, err
    }

    return &LLMApplication{
        mcpClient: mcpClient,
        llmClient: NewLLMClient(),
    },
    nil
}

func (app *LLMApplication) ProcessUserQuery(ctx context.Context, query string) (string, error) {
    // Get available tools for the LLM
    tools, err := app.mcpClient.ListTools(ctx)
    if err != nil {
        return "", err
    }

    // Send query to LLM with available tools
    response, toolCalls, err := app.llmClient.Chat(ctx, query, tools.Tools)
    if err != nil {
        return "", err
    }

    // Execute any tool calls
    for _, toolCall := range toolCalls {
        result, err := app.mcpClient.CallTool(ctx, mcp.CallToolRequest{
            Params: mcp.CallToolRequestParams{
                Name:      toolCall.Name,
                Arguments: toolCall.Arguments,
            },
        })
        if err != nil {
            return "", fmt.Errorf("tool call failed: %w", err)
        }

        // Send tool result back to LLM
        response, err = app.llmClient.ContinueWithToolResult(ctx, toolCall.ID, result)
        if err != nil {
            return "", err
        }
    }

    return response, nil
}
```

----------------------------------------

TITLE: Initialize and Start Concurrent Multi-Transport Go Server
DESCRIPTION: This Go `main` function demonstrates how to initialize an `MCPServer` and concurrently start multiple transports: STDIO, SSE (on port 8080), and StreamableHTTP (on port 8081). It includes proper error handling for each transport, logging, and a mechanism to wait for any server failure.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/index.mdx#_snippet_2

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("Multi-Transport", "1.0.0")
    
    // Add your tools, resources, prompts...
    setupServer(s)
    
    // Start multiple transports concurrently with proper error handling
    errChan := make(chan error, 3)
    
    go func() {
        log.Println("Starting STDIO server...")
        if err := server.ServeStdio(s); err != nil {
            log.Printf("STDIO server error: %v", err)
            errChan <- fmt.Errorf("STDIO server failed: %w", err)
        }
    }()
    
    go func() {
        log.Println("Starting SSE server on :8080...")
        sseServer := server.NewSSEServer(s)
        if err := sseServer.Start(":8080"); err != nil {
            log.Printf("SSE server error: %v", err)
            errChan <- fmt.Errorf("SSE server failed: %w", err)
        }
    }()
    
    log.Println("Starting StreamableHTTP server on :8081...")
    httpServer := server.NewStreamableHTTPServer(s)
    if err := httpServer.Start(":8081"); err != nil {
        log.Printf("StreamableHTTP server error: %v", err)
        errChan <- fmt.Errorf("StreamableHTTP server failed: %w", err)
    }
    
    // Wait for any server to fail
    select {
    case err := <-errChan:
        log.Printf("Server failed: %v", err)
        return
    }
}

// Helper function for the multi-transport example
func setupServer(s *server.MCPServer) {
    // Placeholder implementation - would add tools, resources, etc.
}
```

----------------------------------------

TITLE: Create Advanced MCP-Go STDIO Server
DESCRIPTION: This Go code demonstrates how to set up an advanced MCP-Go STDIO server with various capabilities (resource, prompt, tool) and logging. It includes placeholder functions for adding system, file, Git, and database tools, and implements a robust graceful shutdown mechanism.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_1

LANGUAGE: go
CODE:
```
package main
import (
    "context"
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    s := server.NewMCPServer("Advanced CLI Tool", "1.0.0",
        server.WithResourceCapabilities(true, true),
        server.WithPromptCapabilities(true),
        server.WithToolCapabilities(true),
        server.WithLogging(),
    )

    // Add comprehensive tools
    addSystemTools(s)
    addFileTools(s)
    addGitTools(s)
    addDatabaseTools(s)

    // Handle graceful shutdown
    setupGracefulShutdown(s)

    // Start with error handling
    if err := server.ServeStdio(s); err != nil {
        logError(fmt.Sprintf("Server error: %v", err))
        os.Exit(1)
    }
}

// Helper functions for the advanced example
func logToFile(message string) {
    // Placeholder implementation
    log.Println(message)
}

func logError(message string) {
    // Placeholder implementation
    log.Printf("ERROR: %s", message)
}

func addSystemTools(s *server.MCPServer) {
    // Placeholder implementation
}

func addFileTools(s *server.MCPServer) {
    // Placeholder implementation
}

func addGitTools(s *server.MCPServer) {
    // Placeholder implementation
}

func addDatabaseTools(s *server.MCPServer) {
    // Placeholder implementation
}

func setupGracefulShutdown(s *server.MCPServer) {
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-c
        logToFile("Received shutdown signal")
        
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        if err := s.Shutdown(ctx); err != nil {
            logError(fmt.Sprintf("Shutdown error: %v", err))
        }
        
        os.Exit(0)
    }()
}
```

----------------------------------------

TITLE: Extract Tool Parameters in Go Handlers
DESCRIPTION: This Go code provides examples of helper methods available on `mcp.CallToolRequest` for type-safe parameter extraction within tool handlers. It covers methods for retrieving required parameters (returning an error if missing), optional parameters with defaults, binding arguments to a Go struct, and accessing raw arguments for advanced use cases.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// Required parameters - return error if missing or wrong type
name, err := req.RequireString("name")
age, err := req.RequireInt("age") 
price, err := req.RequireFloat("price")
enabled, err := req.RequireBool("enabled")

// Optional parameters with defaults
name := req.GetString("name", "default")
count := req.GetInt("count", 10)
price := req.GetFloat("price", 0.0)
enabled := req.GetBool("enabled", false)

// Structured data binding
type Config struct {
    Timeout int    `json:"timeout"`
    Retries int    `json:"retries"`
    Debug   bool   `json:"debug"`
}
var config Config
if err := req.BindArguments(&config); err != nil {
    return mcp.NewToolResultError(err.Error()), nil
}

// Raw access (for backward compatibility)
args := req.GetArguments() // returns map[string]any
rawArgs := req.GetRawArguments() // returns any
```

----------------------------------------

TITLE: Go: Stream Large Files for Memory-Efficient Processing
DESCRIPTION: This Go function illustrates how to handle large files without loading them entirely into memory. It uses `os.Open` and `file.Read` with a fixed-size buffer to process data in chunks, preventing excessive memory consumption, and includes context cancellation (`ctx.Done()`) for graceful termination during long-running operations.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_12

LANGUAGE: go
CODE:
```
func handleLargeFile(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    path := req.GetString("path", "")
    
    // Stream large files instead of loading into memory
    file, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    // Process in chunks
    const chunkSize = 64 * 1024
    buffer := make([]byte, chunkSize)
    
    var result strings.Builder
    for {
        n, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            return nil, err
        }
        
        // Process chunk
        processed := processChunk(buffer[:n])
        result.WriteString(processed)
        
        // Check for cancellation
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }
    }

    return mcp.NewToolResultText(result.String()), nil
}
```

----------------------------------------

TITLE: Go: Basic SSE Server with Tools, Resources, and Notifications
DESCRIPTION: This Go code implements a complete Server-Sent Events (SSE) server using the `mcp-go` framework. It defines an `MCPServer` with capabilities for tools and resources. Two tools, `stream_data` and `monitor_system`, are added to demonstrate real-time data processing and system metric collection with client notifications. A dynamic resource, `metrics://current`, is also defined to provide current system metrics. The `main` function initializes and starts the SSE server, while helper functions handle the logic for tool calls and resource reads, including context cancellation and sending progress updates or real-time metric notifications.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/sse.mdx#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    s := server.NewMCPServer("SSE Server", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithResourceCapabilities(true, true),
    )

    // Add real-time tools
    s.AddTool(
        mcp.NewTool("stream_data",
            mcp.WithDescription("Stream data with real-time updates"),
            mcp.WithString("source", mcp.Required()),
            mcp.WithNumber("count", mcp.DefaultNumber(10)),
        ),
        handleStreamData,
    )

    s.AddTool(
        mcp.NewTool("monitor_system",
            mcp.WithDescription("Monitor system metrics in real-time"),
            mcp.WithNumber("duration", mcp.DefaultNumber(60)),
        ),
        handleSystemMonitor,
    )

    // Add dynamic resources
    s.AddResource(
        mcp.NewResource(
            "metrics://current",
            "Current System Metrics",
            mcp.WithResourceDescription("Real-time system metrics"),
            mcp.WithMIMEType("application/json"),
        ),
        handleCurrentMetrics,
    )

    // Start SSE server
    log.Println("Starting SSE server on :8080")
    sseServer := server.NewSSEServer(s)
    if err := sseServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}

func handleStreamData(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    source := req.GetString("source", "")
    count := req.GetInt("count", 10)

    // Get server from context for notifications
    mcpServer := server.ServerFromContext(ctx)

    // Stream data with progress updates
    var results []map[string]interface{}
    for i := 0; i < count; i++ {
        // Check for cancellation
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }

        // Simulate data processing
        data := generateData(source, i)
        results = append(results, data)

        // Send progress notification
        if mcpServer != nil {
            err := mcpServer.SendNotificationToClient(ctx, "notifications/progress", map[string]interface{}{
                "progress": i + 1,
                "total":    count,
                "message":  fmt.Sprintf("Processed %d/%d items from %s", i+1, count, source),
            })
            if err != nil {
                log.Printf("Failed to send notification: %v", err)
            }
        }

        time.Sleep(100 * time.Millisecond)
    }

    return mcp.NewToolResultText(fmt.Sprintf(`{\"source\":\"%s\",\"results\":%v,\"count\":%d}`, 
        source, results, len(results))), nil
}

// Helper functions for the examples
func generateData(source string, index int) map[string]interface{} {
    return map[string]interface{}{
        "source": source,
        "index":  index,
        "value":  fmt.Sprintf("data_%d", index),
    }
}

func handleSystemMonitor(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    duration := req.GetInt("duration", 60)
    
    mcpServer := server.ServerFromContext(ctx)

    // Monitor system for specified duration
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    timeout := time.After(time.Duration(duration) * time.Second)
    var metrics []map[string]interface{}

    for {
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        case <-timeout:
            return mcp.NewToolResultText(fmt.Sprintf(`{\"duration\":%d,\"metrics\":%v,\"samples\":%d}`,
                duration, metrics, len(metrics))), nil
        case <-ticker.C:
            // Collect current metrics
            currentMetrics := collectSystemMetrics()
            metrics = append(metrics, currentMetrics)

            // Send real-time update
            if mcpServer != nil {
                err := mcpServer.SendNotificationToClient(ctx, "system_metrics", currentMetrics)
                if err != nil {
                    log.Printf("Failed to send system metrics notification: %v", err)
                }
            }
        }
    }
}

func collectSystemMetrics() map[string]interface{} {
    // Placeholder implementation
    return map[string]interface{}{
        "cpu":    50.5,
        "memory": 75.2,
        "disk":   30.1,
    }
}

func handleCurrentMetrics(ctx context.Context, req mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    metrics := collectSystemMetrics()
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: "application/json",
            Text:     fmt.Sprintf(`{\"cpu\":%.1f,\"memory\":%.1f,\"disk\":%.1f}`, metrics["cpu"], metrics["memory"], metrics["disk"]),
        },
    }, nil
}
```

----------------------------------------

TITLE: Handle Tool Errors in Go
DESCRIPTION: This Go function illustrates different strategies for handling errors within a tool. It distinguishes between validation errors (returning mcp.NewToolResultError), business logic errors, and system errors (returning Go errors or structured error results).
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_14

LANGUAGE: go
CODE:
```
func handleToolWithErrors(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // For validation errors, return error result (not Go error)
    name, err := req.RequireString("name")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    // For business logic errors, also return error result
    if someCondition {
        return mcp.NewToolResultError("invalid input: " + reason), nil
    }
    
    // For system errors, you can return Go errors
    if systemError {
        return nil, fmt.Errorf("system failure: %v", err)
    }
    
    // Or return structured error information
    return &mcp.CallToolResult{
        Content: []mcp.Content{
            {
                Type: "text", 
                Text: "Operation failed",
            },
        },
        IsError: true,
    }, nil
}
```

----------------------------------------

TITLE: Handle Database Query Tool in Go
DESCRIPTION: This snippet provides the 'handleDatabaseQuery' function for an MCP tool that executes database queries. It demonstrates how to bind tool arguments (query string and parameters) to a Go struct, perform basic security validation (allowing only SELECT queries), execute the query with a context timeout, and convert the results into a JSON format for the tool's output. A helper function 'isSelectQuery' is also included.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_6

LANGUAGE: go
CODE:
```
func handleDatabaseQuery(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Define struct to bind both Query and Params
    var args struct {
        Query  string        `json:"query"`
        Params []interface{} `json:"params"`
    }
    
    // Bind arguments to the struct
    if err := req.BindArguments(&args); err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    // Extract values from the bound struct
    query := args.Query
    params := args.Params
    
    // Validate query for security (basic example)
    if !isSelectQuery(query) {
        return mcp.NewToolResultError("only SELECT queries are allowed"), nil
    }
    
    // Execute query with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    rows, err := db.QueryContext(ctx, query, params...)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("query failed: %v", err)), nil
    }
    defer rows.Close()
    
    // Convert results to JSON
    results, err := rowsToJSON(rows)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to process results: %v", err)), nil
    }
    
    resultData := map[string]interface{}{
        "query":   query,
        "results": results,
        "count":   len(results),
    }
    
    jsonData, err := json.Marshal(resultData)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal results: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}

func isSelectQuery(query string) bool {
    trimmed := strings.TrimSpace(strings.ToUpper(query))
    return strings.HasPrefix(trimmed, "SELECT")
}
```

----------------------------------------

TITLE: Validate Tool Arguments Against Schema in Go
DESCRIPTION: This Go code snippet defines functions to validate tool arguments against a provided input schema. It checks for missing required arguments, unknown arguments, and ensures that argument types match the schema definitions. The `callToolWithValidation` function integrates this validation before invoking a tool.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_6

LANGUAGE: go
CODE:
```
func validateToolArguments(tool mcp.Tool, args map[string]interface{}) error {
    schema := tool.InputSchema
    
    // Check required properties
    if schema.Required != nil {
        for _, required := range schema.Required {
            if _, exists := args[required]; !exists {
                return fmt.Errorf("missing required argument: %s", required)
            }
        }
    }

    // Validate argument types
    if schema.Properties != nil {
        for name, value := range args {
            propSchema, exists := schema.Properties[name]
            if !exists {
                return fmt.Errorf("unknown argument: %s", name)
            }

            if err := validateValue(value, propSchema); err != nil {
                return fmt.Errorf("invalid argument %s: %w", name, err)
            }
        }
    }

    return nil
}

func validateValue(value interface{}, schema map[string]any) error {
    schemaType, ok := schema["type"].(string)
    if !ok {
        return fmt.Errorf("schema missing type")
    }
    
    switch schemaType {
    case "string":
        if _, ok := value.(string); !ok {
            return fmt.Errorf("expected string, got %T", value)
        }
    case "number":
        if _, ok := value.(float64); !ok {
            return fmt.Errorf("expected number, got %T", value)
        }
    case "integer":
        if _, ok := value.(float64); !ok {
            return fmt.Errorf("expected integer, got %T", value)
        }
    case "boolean":
        if _, ok := value.(bool); !ok {
            return fmt.Errorf("expected boolean, got %T", value)
        }
    case "array":
        if _, ok := value.([]interface{}); !ok {
            return fmt.Errorf("expected array, got %T", value)
        }
    case "object":
        if _, ok := value.(map[string]interface{}); !ok {
            return fmt.Errorf("expected object, got %T", value)
        }
    }

    return nil
}

func callToolWithValidation(ctx context.Context, c client.Client, toolName string, args map[string]interface{}) (*mcp.CallToolResult, error) {
    // Get tool schema
    tools, err := c.ListTools(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to list tools: %w", err)
    }

    var tool *mcp.Tool
    for _, t := range tools.Tools {
        if t.Name == toolName {
            tool = &t
            break
        }
    }

    if tool == nil {
        return nil, fmt.Errorf("tool not found: %s", toolName)
    }

    // Validate arguments
    if err := validateToolArguments(*tool, args); err != nil {
        return nil, fmt.Errorf("argument validation failed: %w", err)
    }

    // Call tool
    return callTool(ctx, c, toolName, args)
}
```

----------------------------------------

TITLE: Defining and Implementing an HTTP Request Tool in Go
DESCRIPTION: This snippet illustrates how to define an 'http_request' tool with arguments for HTTP method, URL (validated by a pattern), and an optional request body. The handler function demonstrates creating and executing HTTP requests, handling potential errors during request creation or execution, and returning the response status and body as a text result.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_7

LANGUAGE: Go
CODE:
```
httpTool := mcp.NewTool("http_request",
    mcp.WithDescription("Make HTTP requests to external APIs"),
    mcp.WithString("method",
        mcp.Required(),
        mcp.Description("HTTP method to use"),
        mcp.Enum("GET", "POST", "PUT", "DELETE"),
    ),
    mcp.WithString("url",
        mcp.Required(),
        mcp.Description("URL to send the request to"),
        mcp.Pattern("^https?://.*",
    ),
    mcp.WithString("body",
        mcp.Description("Request body (for POST/PUT)"),
    ),
)

s.AddTool(httpTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    args := request.GetArguments()
    method := args["method"].(string)
    url := args["url"].(string)
    body := ""
    if b, ok := args["body"].(string); ok {
        body = b
    }

    // Create and send request
    var req *http.Request
    var err error
    if body != "" {
        req, err = http.NewRequest(method, url, strings.NewReader(body))
    } else {
        req, err = http.NewRequest(method, url, nil)
    }
    if err != nil {
        return mcp.NewToolResultErrorFromErr("unable to create request", err), nil
    }

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return mcp.NewToolResultErrorFromErr("unable to execute request", err), nil
    }
    defer resp.Body.Close()

    // Return response
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return mcp.NewToolResultErrorFromErr("unable to read request response", err), nil
    }

    return mcp.NewToolResultText(fmt.Sprintf("Status: %d\nBody: %s", resp.StatusCode, string(respBody))), nil
})
```

----------------------------------------

TITLE: Adding a Database Query Builder Prompt with Embedded Schema in MCP-Go (Go)
DESCRIPTION: This snippet showcases a 'query_builder' prompt designed to assist with SQL query construction. It requires a 'table' argument and embeds a 'application/json' resource representing the database schema, enabling the LLM to generate efficient and safe queries based on the provided schema.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_10

LANGUAGE: Go
CODE:
```
// Database query builder prompt
s.AddPrompt(mcp.NewPrompt("query_builder",
    mcp.WithPromptDescription("SQL query builder assistance"),
    mcp.WithArgument("table",
        mcp.ArgumentDescription("Name of the table to query"),
        mcp.RequiredArgument(),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    tableName := request.Params.Arguments["table"]
    if tableName == "" {
        return nil, fmt.Errorf("table name is required")
    }
    
    return mcp.NewGetPromptResult(
        "SQL query builder assistance",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleUser,
                mcp.NewTextContent("Help construct efficient and safe queries for the provided schema."),
            ),
            mcp.NewPromptMessage(
                mcp.RoleUser,
                mcp.NewEmbeddedResource(mcp.ResourceContents{
                    URI: fmt.Sprintf("db://schema/%s", tableName),
                    MIMEType: "application/json",
                }),
            ),
        },
    ), nil
})
```

----------------------------------------

TITLE: Go Client Prompt Template Processing and Formatting
DESCRIPTION: This snippet introduces a `PromptProcessor` struct to encapsulate prompt-related logic. It demonstrates how to process a prompt template to retrieve its messages, build a conversation by appending a user message, and format the resulting messages into a structure suitable for consumption by a Large Language Model (LLM).
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_9

LANGUAGE: go
CODE:
```
type PromptProcessor struct {
    client client.Client
}

func NewPromptProcessor(c client.Client) *PromptProcessor {
    return &PromptProcessor{client: c}
}

func (pp *PromptProcessor) ProcessPrompt(ctx context.Context, name string, args map[string]interface{}) ([]mcp.PromptMessage, error) {
    result, err := pp.client.GetPrompt(ctx, mcp.GetPromptRequest{
        Params: mcp.GetPromptRequestParams{
            Name:      name,
            Arguments: args,
        },
    })
    if err != nil {
        return nil, err
    }

    return result.Messages, nil
}

func (pp *PromptProcessor) BuildConversation(ctx context.Context, promptName string, args map[string]interface{}, userMessage string) ([]mcp.PromptMessage, error) {
    // Get prompt template
    messages, err := pp.ProcessPrompt(ctx, promptName, args)
    if err != nil {
        return nil, err
    }

    // Add user message
    messages = append(messages, mcp.PromptMessage{
        Role: "user",
        Content: mcp.TextContent(userMessage),
    })

    return messages, nil
}

func (pp *PromptProcessor) FormatForLLM(messages []mcp.PromptMessage) []map[string]interface{} {
    formatted := make([]map[string]interface{}, len(messages))
    
    for i, message := range messages {
        formatted[i] = map[string]interface{}{
            "role":    message.Role,
            "content": message.Content.Text,
        }
    }
    
    return formatted
}
```

----------------------------------------

TITLE: Go: MCP Client Constructor Patterns
DESCRIPTION: Demonstrates various client constructors provided by MCP-Go for different communication transports, including STDIO, StreamableHTTP, SSE, and In-process clients.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_0

LANGUAGE: go
CODE:
```
// STDIO client - for command-line tools
client, err := client.NewStdioMCPClient("command", "arg1", "arg2")

// StreamableHTTP client - for web services
client := client.NewStreamableHttpClient("http://localhost:8080/mcp")

// SSE client - for real-time web applications
client := client.NewSSEMCPClient("http://localhost:8080/mcp/sse")

// In-process client - for testing and embedded scenarios
client := client.NewInProcessClient(server)
```

----------------------------------------

TITLE: Go: Implement Thread-Safe Resource Caching with TTL
DESCRIPTION: This Go snippet defines a `CachedResourceHandler` struct and its associated methods to manage a cache of `mcp.ReadResourceResult` objects. It employs a read-write mutex (`sync.RWMutex`) for concurrent access safety and a time-to-live (`ttl`) to automatically invalidate stale cache entries, ensuring that frequently accessed but expensive resources are served efficiently from cache while being periodically refreshed.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_13

LANGUAGE: go
CODE:
```
type CachedResourceHandler struct {
    cache map[string]cacheEntry
    mutex sync.RWMutex
    ttl   time.Duration
}

type cacheEntry struct {
    data      *mcp.ReadResourceResult
    timestamp time.Time
}

func (h *CachedResourceHandler) HandleResource(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    h.mutex.RLock()
    if entry, exists := h.cache[req.Params.URI]; exists {
        if time.Since(entry.timestamp) < h.ttl {
            h.mutex.RUnlock()
            return entry.data, nil
        }
    }
    h.mutex.RUnlock()

    // Fetch fresh data
    data, err := h.fetchFreshData(ctx, req)
    if err != nil {
        return nil, err
    }

    // Cache the result
    h.mutex.Lock()
    h.cache[req.Params.URI] = cacheEntry{
        data:      data,
        timestamp: time.Now(),
    }
    h.mutex.Unlock()

    return data, nil
}
```

----------------------------------------

TITLE: Manage Go Context for Timeout and Cancellation
DESCRIPTION: This Go code demonstrates how to use context.WithTimeout to set a deadline for an operation and context.WithCancel to allow manual cancellation. It shows how to handle context.DeadlineExceeded and context.Canceled errors, ensuring long-running operations can be gracefully managed.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_10

LANGUAGE: Go
CODE:
```
func demonstrateContextUsage(c client.Client) {
    // Operation with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "long_running_tool",
            Arguments: map[string]interface{}{
                "duration": 60, // seconds
            },
        },
    })

    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Println("Tool call timed out")
        } else {
            log.Printf("Tool call failed: %v", err)
        }
        return
    }

    log.Printf("Tool completed: %+v", result)
}

func demonstrateCancellation(c client.Client) {
    ctx, cancel := context.WithCancel(context.Background())

    // Start operation in goroutine
    go func() {
        result, err := c.CallTool(ctx, mcp.CallToolRequest{
            Params: mcp.CallToolRequestParams{
                Name: "long_running_tool",
            },
        })

        if err != nil {
            if errors.Is(err, context.Canceled) {
                log.Println("Tool call was cancelled")
            } else {
                log.Printf("Tool call failed: %v", err)
            }
            return
        }

        log.Printf("Tool completed: %+v", result)
    }()

    // Cancel after 5 seconds
    time.Sleep(5 * time.Second)
    cancel()
    
    // Wait a bit to see the cancellation
    time.Sleep(1 * time.Second)
}
```

----------------------------------------

TITLE: Initialize and Configure Advanced Go SSE Server with Collaborative Tools
DESCRIPTION: This Go code demonstrates the setup of an advanced Server-Sent Events (SSE) server using the `mcp-go` library. It initializes the server with resource, prompt, and tool capabilities, then adds collaborative tools for shared document editing, real-time chat, and live data updates. The server is configured with a base path, keep-alive interval, and base URL before starting on port 8080.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/sse.mdx#_snippet_1

LANGUAGE: go
CODE:
```
func main() {
    s := server.NewMCPServer("Advanced SSE Server", "1.0.0",
        server.WithResourceCapabilities(true, true),
        server.WithPromptCapabilities(true),
        server.WithToolCapabilities(true),
        server.WithLogging(),
    )

    // Add collaborative tools
    addCollaborativeTools(s)
    addRealTimeResources(s)

    log.Println("Starting advanced SSE server on :8080")
    sseServer := server.NewSSEServer(s,
        server.WithStaticBasePath("/mcp"),
        server.WithKeepAliveInterval(30*time.Second),
        server.WithBaseURL("http://localhost:8080"),
    )
    
    if err := sseServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}

// Helper functions for the advanced example
func addRealTimeResources(s *server.MCPServer) {
    // Placeholder implementation - would add real-time resources
}

func addCollaborativeTools(s *server.MCPServer) {
    // Shared document editing
    s.AddTool(
        mcp.NewTool("edit_document",
            mcp.WithDescription("Edit a shared document"),
            mcp.WithString("doc_id", mcp.Required()),
            mcp.WithString("operation", mcp.Required()),
            mcp.WithObject("data", mcp.Required()),
        ),
        handleDocumentEdit,
    )

    // Real-time chat
    s.AddTool(
        mcp.NewTool("send_message",
            mcp.WithDescription("Send a message to all connected clients"),
            mcp.WithString("message", mcp.Required()),
            mcp.WithString("channel", mcp.DefaultString("general")),
        ),
        handleSendMessage,
    )

    // Live data updates
    s.AddTool(
        mcp.NewTool("subscribe_updates",
            mcp.WithDescription("Subscribe to real-time data updates"),
            mcp.WithString("topic", mcp.Required()),
            mcp.WithArray("filters", mcp.Description("Optional filters")),
        ),
        handleSubscribeUpdates,
    )
}
```

----------------------------------------

TITLE: Proxying External APIs as MCP-Go Resources
DESCRIPTION: Illustrates how to create an MCP-Go resource that acts as a proxy for an external API, specifically a weather API. It shows how to extract parameters from the URI, make an HTTP GET request to an external service, and return the response as JSON. The resource uses a 'weather://{location}' URI pattern.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
// Weather API resource
s.AddResource(
    mcp.NewResource(
        "weather://{location}",
        "Weather Data",
        mcp.WithResourceDescription("Current weather for a location"),
        mcp.WithMIMEType("application/json"),
    ),
    handleWeatherData,
)

func handleWeatherData(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    location := extractLocation(req.Params.URI)
    
    // Call external weather API
    apiURL := fmt.Sprintf("https://api.weather.com/v1/current?location=%s&key=%s", 
        url.QueryEscape(location), os.Getenv("WEATHER_API_KEY"))
    
    resp, err := http.Get(apiURL)
    if err != nil {
        return nil, fmt.Errorf("weather API error: %w", err)
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }

    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            {
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(body),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Implement a Basic Tool Handler in Go
DESCRIPTION: This Go function `handleCalculate` demonstrates a basic pattern for processing tool calls from LLMs. It safely extracts required parameters using `mcp.CallToolRequest` helpers, performs an arithmetic operation based on the 'operation' parameter, handles potential errors like division by zero, and returns a `mcp.CallToolResult` or an error.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_4

LANGUAGE: go
CODE:
```
func handleCalculate(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Extract parameters using helper methods
    operation, err := req.RequireString("operation")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    x, err := req.RequireFloat("x")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    y, err := req.RequireFloat("y")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    // Perform calculation
    var result float64
    switch operation {
    case "add":
        result = x + y
    case "subtract":
        result = x - y
    case "multiply":
        result = x * y
    case "divide":
        if y == 0 {
            return mcp.NewToolResultError("division by zero"), nil
        }
        result = x / y
    default:
        return mcp.NewToolResultError(fmt.Sprintf("unknown operation: %s", operation)), nil
    }
    
    // Return result
    return mcp.NewToolResultText(fmt.Sprintf("%.2f", result)), nil
}
```

----------------------------------------

TITLE: Implement Custom Notification System in Go
DESCRIPTION: This Go code defines a `CustomNotifier` struct for managing and sending custom notifications to client sessions. It provides methods to `RegisterSession`, `UnregisterSession`, `SendAlert` to a specific session, and `BroadcastSystemMessage` to all registered sessions. The system uses channels for non-blocking notification delivery and a mutex for concurrent access to session management.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_13

LANGUAGE: go
CODE:
```
type CustomNotifier struct {
    sessions map[string]chan mcp.Notification
    mutex    sync.RWMutex
}

func NewCustomNotifier() *CustomNotifier {
    return &CustomNotifier{
        sessions: make(map[string]chan mcp.Notification),
    }
}

func (n *CustomNotifier) RegisterSession(sessionID string) {
    n.mutex.Lock()
    defer n.mutex.Unlock()
    
    n.sessions[sessionID] = make(chan mcp.Notification, 100)
}

func (n *CustomNotifier) UnregisterSession(sessionID string) {
    n.mutex.Lock()
    defer n.mutex.Unlock()
    
    if ch, exists := n.sessions[sessionID]; exists {
        close(ch)
        delete(n.sessions, sessionID)
    }
}

func (n *CustomNotifier) SendAlert(sessionID, message string, severity string) {
    n.mutex.RLock()
    defer n.mutex.RUnlock()
    
    if ch, exists := n.sessions[sessionID]; exists {
        select {
        case ch <- mcp.Notification{
            Type: "alert",
            Data: map[string]interface{}{
                "message":  message,
                "severity": severity,
                "timestamp": time.Now().Unix(),
            },
        }:
        default:
            // Channel full, drop notification
        }
    }
}

func (n *CustomNotifier) BroadcastSystemMessage(message string) {
    n.mutex.RLock()
    defer n.mutex.RUnlock()
    
    notification := mcp.Notification{
        Type: "system_message",
        Data: map[string]interface{}{
            "message":   message,
            "timestamp": time.Now().Unix(),
        },
    }
    
    for _, ch := range n.sessions {
        select {
        case ch <- notification:
        default:
            // Channel full, skip this session
        }
    }
}
```

----------------------------------------

TITLE: Create a Dynamic User Profile Resource with URI Templates in Go
DESCRIPTION: This Go example illustrates how to implement a dynamic resource using URI templates, specifically for user profiles. The resource URI `users://{user_id}` allows for parameterized requests. The `handleUserProfile` function extracts the `user_id` from the URI, fetches corresponding data (e.g., from a database), and returns it as a JSON resource. An auxiliary `extractUserID` function is also provided.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// User profile resource with dynamic user ID
s.AddResource(
    mcp.NewResource(
        "users://{user_id}",
        "User Profile",
        mcp.WithResourceDescription("User profile information"),
        mcp.WithMIMEType("application/json"),
    ),
    handleUserProfile,
)

func handleUserProfile(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    // Extract user_id from URI
    userID := extractUserID(req.Params.URI) // "users://123" -> "123"
    
    // Fetch user data (from database, API, etc.)
    user, err := getUserFromDB(userID)
    if err != nil {
        return nil, fmt.Errorf("user not found: %w", err)
    }

    jsonData, err := json.Marshal(user)
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: "application/json",
            Text:     string(jsonData),
        },
    }, nil
}

func extractUserID(uri string) string {
    // Extract ID from "users://123" format
    parts := strings.Split(uri, "://")
    if len(parts) == 2 {
        return parts[1]
    }
    return ""
}
```

----------------------------------------

TITLE: Handling Real-time Subscriptions and Notifications in Go
DESCRIPTION: This Go code demonstrates how to implement real-time notification subscriptions. It checks if a client supports the `client.Subscriber` interface, initiates a subscription to receive notifications, and then processes different types of incoming notifications (e.g., progress, messages, resource updates, tool updates) by unmarshaling their parameters into specific Go structs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_11

LANGUAGE: go
CODE:
```
func handleSubscriptions(ctx context.Context, c client.Client) {
    // Check if client supports subscriptions
    subscriber, ok := c.(client.Subscriber)
    if !ok {
        log.Println("Client does not support subscriptions")
        return
    }

    // Subscribe to notifications
    notifications, err := subscriber.Subscribe(ctx)
    if err != nil {
        log.Printf("Failed to subscribe: %v", err)
        return
    }

    // Handle notifications
    for {
        select {
        case notification := <-notifications:
            handleNotification(notification)
        case <-ctx.Done():
            log.Println("Subscription cancelled")
            return
        }
    }
}

func handleNotification(notification mcp.Notification) {
    switch notification.Method {
    case "notifications/progress":
        handleProgressNotification(notification)
    case "notifications/message":
        handleMessageNotification(notification)
    case "notifications/resources/updated":
        handleResourceUpdateNotification(notification)
    case "notifications/tools/updated":
        handleToolUpdateNotification(notification)
    default:
        log.Printf("Unknown notification: %s", notification.Method)
    }
}

func handleProgressNotification(notification mcp.Notification) {
    var progress mcp.ProgressNotification
    if err := json.Unmarshal(notification.Params, &progress); err != nil {
        log.Printf("Failed to parse progress notification: %v", err)
        return
    }

    fmt.Printf("Progress: %d/%d - %s\n", 
        progress.Progress, 
        progress.Total, 
        progress.Message)
}

func handleMessageNotification(notification mcp.Notification) {
    var message mcp.MessageNotification
    if err := json.Unmarshal(notification.Params, &message); err != nil {
        log.Printf("Failed to parse message notification: %v", err)
        return
    }

    fmt.Printf("Server message: %s\n", message.Text)
}

func handleResourceUpdateNotification(notification mcp.Notification) {
    log.Println("Resources updated, refreshing cache...")
    // Invalidate resource cache or refresh resource list
}

func handleToolUpdateNotification(notification mcp.Notification) {
    log.Println("Tools updated, refreshing tool list...")
    // Refresh tool list
}
```

----------------------------------------

TITLE: Configure MCP server with various options in Go
DESCRIPTION: Shows how to apply configuration options like enabling tool, resource, and prompt capabilities, adding panic recovery, and integrating custom lifecycle hooks during server creation using `server.With...` functions.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_1

LANGUAGE: Go
CODE:
```
s := server.NewMCPServer(
    "Advanced Server",
    "2.0.0",
    server.WithToolCapabilities(true),      // Enable tools
    server.WithResourceCapabilities(true),  // Enable resources  
    server.WithPromptCapabilities(true),    // Enable prompts
    server.WithRecovery(),                  // Add panic recovery
    server.WithHooks(myHooks),              // Add lifecycle hooks
)
```

----------------------------------------

TITLE: MCP-Go Server Initialization and Tool Exposure
DESCRIPTION: This Go snippet demonstrates how to initialize an MCP server, add tools and resources, and start serving requests over standard I/O. Servers are passive components that expose functionalities to LLMs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_4

LANGUAGE: go
CODE:
```
// Server example - exposes functionality
s := server.NewMCPServer("Database Tools", "1.0.0")
s.AddTool(queryTool, handleQuery)
s.AddResource(tableResource, handleTableAccess)
server.ServeStdio(s)
```

----------------------------------------

TITLE: Handle HTTP Requests in MCP-Go
DESCRIPTION: This Go function demonstrates how to create and execute HTTP requests within the MCP-Go framework. It extracts URL, method, and optional body/headers from the mcp.CallToolRequest, performs the HTTP call, and returns the status code, headers, and body as a JSON result. It includes error handling and a timeout.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_7

LANGUAGE: Go
CODE:
```
func handleHTTPRequest(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    url, err := req.RequireString("url")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    method, err := req.RequireString("method")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    body := req.GetString("body", "")
    
    // Handle headers (optional object parameter)
    var headers map[string]interface{}
    if args := req.GetArguments(); args != nil {
        if h, ok := args["headers"].(map[string]interface{}); ok {
            headers = h
        }
    }
    
    // Create HTTP request
    httpReq, err := http.NewRequestWithContext(ctx, method, url, strings.NewReader(body))
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to create request: %v", err)), nil
    }
    
    // Add headers
    for key, value := range headers {
        httpReq.Header.Set(key, fmt.Sprintf("%v", value))
    }
    
    // Execute request with timeout
    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("request failed: %v", err)), nil
    }
    defer resp.Body.Close()
    
    // Read response
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to read response: %v", err)), nil
    }
    
    resultData := map[string]interface{}{
        "status_code": resp.StatusCode,
        "headers":     resp.Header,
        "body":        string(respBody)
    }
    
    jsonData, err := json.Marshal(resultData)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}
```

----------------------------------------

TITLE: Defining Dynamic Resource Template in MCP Go
DESCRIPTION: This snippet illustrates how to define a dynamic resource template in MCP Go, allowing for parameterized data retrieval. It uses `mcp.NewResourceTemplate` with a URI template ('users://{id}/profile') to define a resource that can fetch user profiles based on an ID. The handler extracts the ID from the request URI, simulates a data fetch (`getUserProfile`), and returns the profile as JSON content, demonstrating how to serve variable data.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_5

LANGUAGE: Go
CODE:
```
// Dynamic resource example - user profiles by ID
template := mcp.NewResourceTemplate(
    "users://{id}/profile",
    "User Profile",
    mcp.WithTemplateDescription("Returns user profile information"),
    mcp.WithTemplateMIMEType("application/json"),
)

// Add template with its handler
s.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract ID from the URI using regex matching
    // The server automatically matches URIs to templates
    userID := extractIDFromURI(request.Params.URI)
    
    profile, err := getUserProfile(userID)  // Your DB/API call here
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      request.Params.URI,
            MIMEType: "application/json",
            Text:     profile,
        },
    }, nil
})
```

----------------------------------------

TITLE: MCP-Go Parameter Extraction Helper Methods
DESCRIPTION: This Go snippet showcases various helper methods provided by MCP-Go for extracting different data types (string, int, float, bool) as both required and optional parameters. It also demonstrates how to bind request arguments directly to a Go struct for structured data handling.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
// Required parameters (return error if missing or wrong type)
name, err := req.RequireString("name")
age, err := req.RequireInt("age")
price, err := req.RequireFloat("price")
enabled, err := req.RequireBool("enabled")

// Optional parameters with defaults
name := req.GetString("name", "default")
count := req.GetInt("count", 10)
price := req.GetFloat("price", 0.0)
enabled := req.GetBool("enabled", false)

// Structured data binding
type UserData struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}
var user UserData
if err := req.BindArguments(&user); err != nil {
    return mcp.NewToolResultError(err.Error()), nil
}
```

----------------------------------------

TITLE: Go Client Health Monitoring
DESCRIPTION: This snippet defines a `ClientHealthMonitor` that periodically checks the health of an underlying client connection. It attempts a simple client operation (e.g., `ListTools`) at a specified interval and timeout, updating an internal boolean status. The `IsHealthy` method allows external components to query the current health state.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_11

LANGUAGE: Go
CODE:
```
type ClientHealthMonitor struct {
    client   client.Client
    interval time.Duration
    timeout  time.Duration
    healthy  bool
    mutex    sync.RWMutex
}

func NewClientHealthMonitor(c client.Client, interval, timeout time.Duration) *ClientHealthMonitor {
    return &ClientHealthMonitor{
        client:   c,
        interval: interval,
        timeout:  timeout,
        healthy:  false,
    }
}

func (chm *ClientHealthMonitor) Start(ctx context.Context) {
    ticker := time.NewTicker(chm.interval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            chm.checkHealth(ctx)
        }
    }
}

func (chm *ClientHealthMonitor) checkHealth(ctx context.Context) {
    ctx, cancel := context.WithTimeout(ctx, chm.timeout)
    defer cancel()

    // Try to list tools as a health check
    _, err := chm.client.ListTools(ctx)
    
    chm.mutex.Lock()
    chm.healthy = (err == nil)
    chm.mutex.Unlock()

    if err != nil {
        log.Printf("Health check failed: %v", err)
    }
}

func (chm *ClientHealthMonitor) IsHealthy() bool {
    chm.mutex.RLock()
    defer chm.mutex.RUnlock()
    return chm.healthy
}
```

----------------------------------------

TITLE: Initialize MCP-Go StreamableHTTP Server with Tools and Resources
DESCRIPTION: This snippet demonstrates the setup of a `StreamableHTTP` server using `mcp-go`. It initializes the server, enables tool and resource capabilities, and registers three RESTful tools (`get_user`, `create_user`, `search_users`) and one resource (`users://{user_id}`). Each tool is defined with its description and parameters, including types, requirements, and default values, before starting the HTTP server.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "strings"
    "time"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    s := server.NewMCPServer("StreamableHTTP API Server", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithResourceCapabilities(true, true),
    )

    // Add RESTful tools
    s.AddTool(
        mcp.NewTool("get_user",
            mcp.WithDescription("Get user information"),
            mcp.WithString("user_id", mcp.Required()),
        ),
        handleGetUser,
    )

    s.AddTool(
        mcp.NewTool("create_user",
            mcp.WithDescription("Create a new user"),
            mcp.WithString("name", mcp.Required()),
            mcp.WithString("email", mcp.Required()),
            mcp.WithNumber("age", mcp.Min(0)),
        ),
        handleCreateUser,
    )

    s.AddTool(
        mcp.NewTool("search_users",
            mcp.WithDescription("Search users with filters"),
            mcp.WithString("query", mcp.Description("Search query")),
            mcp.WithNumber("limit", mcp.DefaultNumber(10), mcp.Max(100)),
            mcp.WithNumber("offset", mcp.DefaultNumber(0), mcp.Min(0)),
        ),
        handleSearchUsers,
    )

    // Add resources
    s.AddResource(
        mcp.NewResource(
            "users://{user_id}",
            "User Profile",
            mcp.WithResourceDescription("User profile data"),
            mcp.WithMIMEType("application/json"),
        ),
        handleUserResource,
    )

    // Start StreamableHTTP server
    log.Println("Starting StreamableHTTP server on :8080")
    httpServer := server.NewStreamableHTTPServer(s)
    if err := httpServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}
```

----------------------------------------

TITLE: Register and Handle File Creation Tool in Go
DESCRIPTION: This snippet demonstrates how to initialize an MCP server, define a 'create_file' tool with required parameters (path, content) and an optional encoding, and implement the 'handleCreateFile' function. The handler includes input validation (e.g., path traversal prevention), supports different encodings (UTF-8, ASCII, Base64), and writes content to a specified file.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_5

LANGUAGE: go
CODE:
```
func main() {
    s := server.NewMCPServer("File Tools", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // File creation tool
    createFileTool := mcp.NewTool("create_file",
        mcp.WithDescription("Create a new file with content"),
        mcp.WithString("path", 
            mcp.Required(),
            mcp.Description("File path to create"),
        ),
        mcp.WithString("content",
            mcp.Required(), 
            mcp.Description("File content"),
        ),
        mcp.WithString("encoding",
            mcp.Default("utf-8"),
            mcp.Enum("utf-8", "ascii", "base64"),
            mcp.Description("File encoding"),
        ),
    )

    s.AddTool(createFileTool, handleCreateFile)
    server.ServeStdio(s)
}

func handleCreateFile(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    path, err := req.RequireString("path")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    content, err := req.RequireString("content")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    encoding := req.GetString("encoding", "utf-8")
    
    // Validate path for security
    if strings.Contains(path, "..") {
        return mcp.NewToolResultError("invalid path: directory traversal not allowed"), nil
    }
    
    // Handle different encodings
    var data []byte
    switch encoding {
    case "utf-8":
        data = []byte(content)
    case "ascii":
        data = []byte(content)
    case "base64":
        var err error
        data, err = base64.StdEncoding.DecodeString(content)
        if err != nil {
            return mcp.NewToolResultError(fmt.Sprintf("invalid base64 content: %v", err)), nil
        }
    }
    
    // Create file
    if err := os.WriteFile(path, data, 0644); err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to create file: %v", err)), nil
    }
    
    return mcp.NewToolResultText(fmt.Sprintf("File created successfully: %s", path)), nil
}
```

----------------------------------------

TITLE: Implement Robust Error Handling in Go MCP Tool
DESCRIPTION: This Go function `handleToolWithErrors` demonstrates comprehensive error handling for an MCP tool. It includes validation for required parameters, path security checks, file existence verification, context cancellation handling, and operation timeouts, returning user-friendly error messages.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_9

LANGUAGE: go
CODE:
```
func handleToolWithErrors(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Validate required parameters
    path, err := req.RequireString("path")
    if err != nil {
        return nil, fmt.Errorf("path parameter is required and must be a string")
    }

    // Validate path security
    if !isValidPath(path) {
        return nil, fmt.Errorf("invalid or unsafe path: %s", path)
    }

    // Check if path exists
    if _, err := os.Stat(path); os.IsNotExist(err) {
        return nil, fmt.Errorf("path does not exist: %s", path)
    }

    // Handle context cancellation
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }

    // Perform operation with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    result, err := performOperation(ctx, path)
    if err != nil {
        // Log error for debugging
        logError(fmt.Sprintf("Operation failed for path %s: %v", path, err))
        
        // Return user-friendly error
        if errors.Is(err, context.DeadlineExceeded) {
            return nil, fmt.Errorf("operation timed out")
        }
        
        return nil, fmt.Errorf("operation failed: %w", err)
    }

    return mcp.NewToolResultText(fmt.Sprintf("%v", result)), nil
}
```

----------------------------------------

TITLE: Send Real-time Progress Notifications in Go
DESCRIPTION: This Go function `handleLongRunningTool` simulates a long-running operation and demonstrates how to send real-time custom progress notifications to all connected clients. It uses `server.ServerFromContext` to access the server instance and `SendNotificationToAllClients` to broadcast updates, including progress percentage and messages, ensuring clients are informed of ongoing tasks.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_12

LANGUAGE: go
CODE:
```
func handleLongRunningTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    srv := server.ServerFromContext(ctx)
    
    // Simulate long-running work
    for i := 0; i < 100; i++ {
        time.Sleep(100 * time.Millisecond)
        
        // Send custom notification to all clients
        notification := map[string]interface{}{
            "type":     "progress",
            "progress": i + 1,
            "total":    100,
            "message":  fmt.Sprintf("Processing step %d/100", i+1),
        }
        
        srv.SendNotificationToAllClients("progress", notification)
    }
    
    return mcp.NewToolResultText("Long operation completed successfully"), nil
}
```

----------------------------------------

TITLE: Implement Streaming Tool Results in Go
DESCRIPTION: This Go function shows how to implement a long-running tool that provides progress updates or streams results. It simulates work, checks for context cancellation, and aggregates results before returning a final JSON payload.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_16

LANGUAGE: go
CODE:
```
func handleStreamingTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // For operations that take time, provide progress updates
    results := []string{}
    
    for i := 0; i < 10; i++ {
        // Simulate work
        time.Sleep(100 * time.Millisecond)
        
        // Check for cancellation
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }
        
        results = append(results, fmt.Sprintf("Processed item %d", i+1))
    }
    
    resultData := map[string]interface{}{
        "status":  "completed",
        "results": results,
    }
    
    jsonData, err := json.Marshal(resultData)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}
```

----------------------------------------

TITLE: Go MCP Server Integration with Session-Aware Tools
DESCRIPTION: Illustrates how to integrate the session manager with an MCP server. It shows how to use server hooks to manage session creation and removal, and how to implement a `ToolHandler` that retrieves session information to enforce permissions and access user-specific data based on the active session.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_4

LANGUAGE: go
CODE:
```
func main() {
    sessionManager := NewSessionManager()
    
    hooks := &server.Hooks{}
    
    hooks.AddOnRegisterSession(func(ctx context.Context, session server.ClientSession) {
        // Initialize session with default permissions
        sessionManager.CreateSession(session.ID(), "anonymous", []string{"read"})
        log.Printf("Session %s started", session.ID())
    })
    
    hooks.AddOnUnregisterSession(func(ctx context.Context, session server.ClientSession) {
        sessionManager.RemoveSession(session.ID())
        log.Printf("Session %s ended", session.ID())
    })
    
    s := server.NewMCPServer("Session Server", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithHooks(hooks),
    )

    // Add session-aware tool
    s.AddTool(
        mcp.NewTool("get_user_data",
            mcp.WithDescription("Get user-specific data"),
            mcp.WithString("data_type", mcp.Required()),
        ),
        createSessionAwareTool(sessionManager),
    )

    server.ServeStdio(s)
}

func createSessionAwareTool(sm *SessionManager) server.ToolHandler {
    return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        sessionID := server.GetSessionID(ctx)
        session, exists := sm.GetSession(sessionID)
        if !exists {
            return nil, fmt.Errorf("invalid session")
        }

        dataType := req.Params.Arguments["data_type"].(string)
        
        // Check permissions
        if !hasPermission(session.Permissions, "read") {
            return nil, fmt.Errorf("insufficient permissions")
        }

        // Get user-specific data
        data, err := getUserData(session.UserID, dataType)
        if err != nil {
            return nil, err
        }

        jsonData, err := json.Marshal(data)
        if err != nil {
            return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
        }
        
        return mcp.NewToolResultText(string(jsonData)), nil
    }
}
```

----------------------------------------

TITLE: Go In-Process Client for MCP Testing
DESCRIPTION: This Go code defines a `TestClient` struct and its methods, providing an in-process client for testing interactions with an MCP server. It allows for adding tools and resources, initializing the client, and performing tool calls or resource reads directly within the same process, eliminating network dependencies for unit and integration tests. The example demonstrates how to set up a test client, add a simple 'echo' tool, and verify its functionality.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_12

LANGUAGE: go
CODE:
```
type TestClient struct {
    server *server.MCPServer
    client *client.InProcessClient
}

func NewTestClient() *TestClient {
    s := server.NewMCPServer("Test Server", "1.0.0",
        server.WithAllCapabilities(),
    )

    return &TestClient{
        server: s,
        client: client.NewInProcessClient(s),
    }
}

func (tc *TestClient) AddTool(name, description string, handler server.ToolHandler) {
    tool := mcp.NewTool(name, mcp.WithDescription(description))
    tc.server.AddTool(tool, handler)
}

func (tc *TestClient) AddResource(uri, name string, handler server.ResourceHandler) {
    resource := mcp.NewResource(uri, name)
    tc.server.AddResource(resource, handler)
}

func (tc *TestClient) Initialize(ctx context.Context) error {
    return tc.client.Initialize(ctx)
}

func (tc *TestClient) CallTool(ctx context.Context, name string, args map[string]interface{}) (*mcp.CallToolResult, error) {
    return tc.client.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name:      name,
            Arguments: args,
        },
    })
}

func (tc *TestClient) ReadResource(ctx context.Context, uri string) (*mcp.ReadResourceResult, error) {
    return tc.client.ReadResource(ctx, mcp.ReadResourceRequest{
        Params: mcp.ReadResourceRequestParams{
            URI: uri,
        },
    })
}

func (tc *TestClient) Close() error {
    return tc.client.Close()
}

// Usage in tests
func TestWithInProcessClient(t *testing.T) {
    tc := NewTestClient()
    defer tc.Close()

    // Add test tool
    tc.AddTool("echo", "Echo input", func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        input := req.Params.Arguments["input"].(string)
        return mcp.NewToolResultText(input), nil
    })

    ctx := context.Background()
    err := tc.Initialize(ctx)
    require.NoError(t, err)

    // Test tool call
    result, err := tc.CallTool(ctx, "echo", map[string]interface{}{
        "input": "hello world",
    })
    require.NoError(t, err)
    assert.Equal(t, "hello world", result.Content[0].Text)
}
```

----------------------------------------

TITLE: Initializing and Starting a Basic MCP Server in Go
DESCRIPTION: This example illustrates the fundamental steps to create a new MCP server instance with a specified name and version. It then demonstrates how to start the server to listen for connections via standard I/O, providing a basic setup for an MCP application.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_3

LANGUAGE: go
CODE:
```
// Create a basic server
s := server.NewMCPServer(
    "My Server",  // Server name
    "1.0.0",     // Version
)

// Start the server using stdio
if err := server.ServeStdio(s); err != nil {
    log.Fatalf("Server error: %v", err)
}
```

----------------------------------------

TITLE: Define MCP Prompts in Go
DESCRIPTION: Prompts are reusable templates that structure conversations between users and LLMs. They are template-based, reusable, structured with clear input parameters, and can be context-aware. This snippet illustrates defining a code review prompt and a data analysis prompt.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_2

LANGUAGE: go
CODE:
```
// Code review prompt
reviewPrompt := mcp.NewPrompt("code_review",
    mcp.WithPromptDescription("Review code for best practices and issues"),
    mcp.WithPromptArgument("code", 
        mcp.Required(),
        mcp.Description("The code to review"),
    ),
    mcp.WithPromptArgument("language",
        mcp.Description("Programming language"),
    ),
)

// Data analysis prompt
analysisPrompt := mcp.NewPrompt("analyze_data",
    mcp.WithPromptDescription("Analyze dataset and provide insights"),
    mcp.WithPromptArgument("dataset_uri", mcp.Required()),
    mcp.WithPromptArgument("focus_areas", 
        mcp.Description("Specific areas to focus analysis on"),
    ),
)
```

----------------------------------------

TITLE: Read Typed Resources (JSON, Text, Binary) in Go
DESCRIPTION: These Go helper functions demonstrate how to read different types of resources (JSON, plain text, and binary data) from a specified URI using a client.Client. Each function handles MIME type validation and data parsing/decoding specific to its type, returning an error if the resource content is empty, of an unexpected type, or fails to parse/decode.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// Helper functions for common resource types
func readJSONResource(ctx context.Context, c client.Client, uri string) (map[string]interface{}, error) {
    result, err := readResource(ctx, c, uri)
    if err != nil {
        return nil, err
    }

    if len(result.Contents) == 0 {
        return nil, fmt.Errorf("no content in resource")
    }

    content := result.Contents[0]
    if content.MIMEType != "application/json" {
        return nil, fmt.Errorf("expected JSON, got %s", content.MIMEType)
    }

    var data map[string]interface{}
    if err := json.Unmarshal([]byte(content.Text), &data); err != nil {
        return nil, fmt.Errorf("failed to parse JSON: %w", err)
    }

    return data, nil
}

func readTextResource(ctx context.Context, c client.Client, uri string) (string, error) {
    result, err := readResource(ctx, c, uri)
    if err != nil {
        return "", err
    }

    if len(result.Contents) == 0 {
        return "", fmt.Errorf("no content in resource")
    }

    content := result.Contents[0]
    if !strings.HasPrefix(content.MIMEType, "text/") {
        return "", fmt.Errorf("expected text, got %s", content.MIMEType)
    }

    return content.Text, nil
}

func readBinaryResource(ctx context.Context, c client.Client, uri string) ([]byte, error) {
    result, err := readResource(ctx, c, uri)
    if err != nil {
        return nil, err
    }

    if len(result.Contents) == 0 {
        return nil, fmt.Errorf("no content in resource")
    }

    content := result.Contents[0]
    if content.Blob == "" {
        return nil, fmt.Errorf("no binary data in resource")
    }

    data, err := base64.StdEncoding.DecodeString(content.Blob)
    if err != nil {
        return nil, fmt.Errorf("failed to decode binary data: %w", err)
    }

    return data, nil
}
```

----------------------------------------

TITLE: Run and Initialize Go MCP Server
DESCRIPTION: These bash commands guide you through initializing a Go module, fetching necessary dependencies for `mcp-go`, and then running the 'hello-server' application. This prepares and executes the Go server for interaction.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
cd hello-server
go mod init hello-server
go get github.com/mark3labs/mcp-go
go run main.go
```

----------------------------------------

TITLE: Define Various Parameter Types in Go Tools
DESCRIPTION: This Go code illustrates how to define different parameter types for MCP-Go tools, including strings with length constraints, numbers with range constraints, integers with defaults, booleans, arrays with item types, and objects with nested properties. These definitions ensure robust input validation for LLM-invoked functions.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_1

LANGUAGE: go
CODE:
```
// String parameters
mcp.WithString("name", 
    mcp.Required(),
    mcp.Description("User's name"),
    mcp.MinLength(1),
    mcp.MaxLength(100),
)

// Number parameters  
mcp.WithNumber("age",
    mcp.Required(),
    mcp.Description("User's age"),
    mcp.Minimum(0),
    mcp.Maximum(150),
)

// Integer parameters
mcp.WithInteger("count",
    mcp.Default(10),
    mcp.Description("Number of items"),
    mcp.Minimum(1),
    mcp.Maximum(1000),
)

// Boolean parameters
mcp.WithBoolean("enabled",
    mcp.Default(true),
    mcp.Description("Whether feature is enabled"),
)

// Array parameters
mcp.WithArray("tags",
    mcp.Description("List of tags"),
    mcp.Items(map[string]any{"type": "string"}),
)

// Object parameters
mcp.WithObject("config",
    mcp.Description("Configuration object"),
    mcp.Properties(map[string]any{
        "timeout": map[string]any{"type": "number"},
        "retries": map[string]any{"type": "integer"},
    }),
)
```

----------------------------------------

TITLE: Defining and Implementing a Calculator Tool in Go
DESCRIPTION: This snippet demonstrates how to define a 'calculator' tool using `mcp.NewTool` with required number and enum string arguments, and how to implement its handler function to perform basic arithmetic operations (add, subtract, multiply, divide) and return a formatted number result or an error for division by zero.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_6

LANGUAGE: Go
CODE:
```
calculatorTool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform basic arithmetic calculations"),
    mcp.WithString("operation",
        mcp.Required(),
        mcp.Description("The arithmetic operation to perform"),
        mcp.Enum("add", "subtract", "multiply", "divide"),
    ),
    mcp.WithNumber("x",
        mcp.Required(),
        mcp.Description("First number"),
    ),
    mcp.WithNumber("y",
        mcp.Required(),
        mcp.Description("Second number"),
    ),
)

s.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    args := request.GetArguments()
    op := args["operation"].(string)
    x := args["x"].(float64)
    y := args["y"].(float64)

    var result float64
    switch op {
    case "add":
        result = x + y
    case "subtract":
        result = x - y
    case "multiply":
        result = x * y
    case "divide":
        if y == 0 {
            return mcp.NewToolResultError("cannot divide by zero"), nil
        }
        result = x / y
    }
    
    return mcp.FormatNumberResult(result), nil
})
```

----------------------------------------

TITLE: Initializing MCP Server and Defining Hello World Tool in Go
DESCRIPTION: This Go snippet demonstrates how to initialize an MCP server, define a 'hello_world' tool with a 'name' string parameter, and register a handler function for it. The server is configured to run over standard I/O, facilitating communication between LLM applications and the defined tool. The `helloHandler` function processes the tool request, extracts the 'name' parameter, and returns a greeting.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
    "context"
    "errors"
    "fmt"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func main() {
    // Create a new MCP server
    s := server.NewMCPServer(
        "Demo 🚀",
        "1.0.0",
        server.WithToolCapabilities(false),
    )

    // Add tool
    tool := mcp.NewTool("hello_world",
        mcp.WithDescription("Say hello to someone"),
        mcp.WithString("name",
            mcp.Required(),
            mcp.Description("Name of the person to greet"),
        ),
    )

    // Add tool handler
    s.AddTool(tool, helloHandler)

    // Start the stdio server
    if err := server.ServeStdio(s); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    name, err := request.RequireString("name")
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }

    return mcp.NewToolResultText(fmt.Sprintf("Hello, %s!", name)), nil
}
```

----------------------------------------

TITLE: Define Tool Annotations in Go
DESCRIPTION: This Go snippet demonstrates how to define a new tool with various annotations using the mcp.NewTool builder. It includes examples for string, number, and array parameters with descriptions, requirements, defaults, and constraints, providing hints for LLMs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_15

LANGUAGE: go
CODE:
```
tool := mcp.NewTool("search_database",
    mcp.WithDescription("Search the product database"),
    mcp.WithString("query",
        mcp.Required(),
        mcp.Description("Search query (supports wildcards with *)"),
    ),
    mcp.WithNumber("limit",
        mcp.DefaultNumber(10),
        mcp.Minimum(1),
        mcp.Maximum(100),
        mcp.Description("Maximum number of results to return"),
    ),
    mcp.WithArray("categories",
        mcp.Description("Filter by product categories"),
        mcp.Items(map[string]any{"type": "string"}),
    ),
)

s.AddTool(tool, handleSearchDatabase)
```

----------------------------------------

TITLE: Go Resilient Client with Connection Recovery
DESCRIPTION: This snippet implements a `ResilientClient` that automatically manages its connection. It ensures a connection is established before any operation and attempts to recover the connection upon detecting specific connection-related errors, including a single retry mechanism. It uses a factory function to create new client instances.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_12

LANGUAGE: Go
CODE:
```
type ResilientClient struct {
    factory    func() (client.Client, error)
    client     client.Client
    mutex      sync.RWMutex
    recovering bool
}

func NewResilientClient(factory func() (client.Client, error)) *ResilientClient {
    return &ResilientClient{
        factory: factory,
    }
}

func (rc *ResilientClient) ensureConnected(ctx context.Context) error {
    rc.mutex.RLock()
    if rc.client != nil && !rc.recovering {
        rc.mutex.RUnlock()
        return nil
    }
    rc.mutex.RUnlock()

    rc.mutex.Lock()
    defer rc.mutex.Unlock()

    // Double-check after acquiring write lock
    if rc.client != nil && !rc.recovering {
        return nil
    }

    rc.recovering = true
    defer func() { rc.recovering = false }()

    // Close existing client if any
    if rc.client != nil {
        rc.client.Close()
    }

    // Create new client
    newClient, err := rc.factory()
    if err != nil {
        return fmt.Errorf("failed to create client: %w", err)
    }

    // Initialize new client
    if err := newClient.Initialize(ctx); err != nil {
        newClient.Close()
        return fmt.Errorf("failed to initialize client: %w", err)
    }

    rc.client = newClient
    return nil
}

func (rc *ResilientClient) CallTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    if err := rc.ensureConnected(ctx); err != nil {
        return nil, err
    }

    rc.mutex.RLock()
    client := rc.client
    rc.mutex.RUnlock()

    result, err := client.CallTool(ctx, req)
    if err != nil && isConnectionError(err) {
        // Mark for recovery and retry once
        rc.mutex.Lock()
        rc.recovering = true
        rc.mutex.Unlock()

        if retryErr := rc.ensureConnected(ctx); retryErr != nil {
            return nil, fmt.Errorf("recovery failed: %w", retryErr)
        }

        rc.mutex.RLock()
        client = rc.client
        rc.mutex.RUnlock()

        return client.CallTool(ctx, req)
    }

    return result, err
}

func isConnectionError(err error) bool {
    return errors.Is(err, client.ErrConnectionLost) ||
           errors.Is(err, client.ErrConnectionFailed)
}
```

----------------------------------------

TITLE: Read MCP Go Resource Content by URI
DESCRIPTION: This Go function demonstrates how to read the content of a specific resource from an MCP server using its URI. It shows how to iterate through the listed resources, read each one, and process its text or blob content, including a utility function to truncate long strings for display.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_2

LANGUAGE: go
CODE:
```
func readResource(ctx context.Context, c client.Client, uri string) (*mcp.ReadResourceResult, error) {
    result, err := c.ReadResource(ctx, mcp.ReadResourceRequest{
        Params: mcp.ReadResourceRequestParams{
            URI: uri,
        },
    })
    if err != nil {
        return nil, fmt.Errorf("failed to read resource %s: %w", uri, err)
    }

    return result, nil
}

func demonstrateResourceReading(ctx context.Context, c client.Client) {
    // List resources first
    resources, err := c.ListResources(ctx)
    if err != nil {
        log.Printf("Failed to list resources: %v", err)
        return
    }

    // Read each resource
    for _, resource := range resources.Resources {
        fmt.Printf("\nReading resource: %s\n", resource.URI)
        
        result, err := readResource(ctx, c, resource.URI)
        if err != nil {
            log.Printf("Failed to read resource %s: %v", resource.URI, err)
            continue
        }

        // Process resource contents
        for i, content := range result.Contents {
            fmt.Printf("Content %d:\n", i+1)
            fmt.Printf("  URI: %s\n", content.URI)
            fmt.Printf("  MIME Type: %s\n", content.MIMEType)
            
            if content.Text != "" {
                fmt.Printf("  Text: %s\n", truncateString(content.Text, 100))
            }
            
            if content.Blob != "" {
                fmt.Printf("  Blob: %d bytes\n", len(content.Blob))
            }
        }
    }
}

func truncateString(s string, maxLen int) string {
    if len(s) <= maxLen {
        return s
    }
    return s[:maxLen] + "..."
}
```

----------------------------------------

TITLE: Go Client Basic Prompt Retrieval and Listing
DESCRIPTION: This snippet demonstrates fundamental operations for managing prompts using the Go client. It includes functions to retrieve a specific prompt by name with arguments and to list all available prompts, displaying their names, descriptions, and arguments. It showcases the `GetPrompt` and `ListPrompts` methods.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_8

LANGUAGE: go
CODE:
```
func getPrompt(ctx context.Context, c client.Client, name string, args map[string]interface{}) (*mcp.GetPromptResult, error) {
    result, err := c.GetPrompt(ctx, mcp.GetPromptRequest{
        Params: mcp.GetPromptRequestParams{
            Name:      name,
            Arguments: args,
        },
    })
    if err != nil {
        return nil, fmt.Errorf("failed to get prompt: %w", err)
    }

    return result, nil
}

func demonstratePromptUsage(ctx context.Context, c client.Client) {
    // List available prompts
    prompts, err := c.ListPrompts(ctx)
    if err != nil {
        log.Printf("Failed to list prompts: %v", err)
        return
    }

    fmt.Printf("Available prompts: %d\n", len(prompts.Prompts))
    for _, prompt := range prompts.Prompts {
        fmt.Printf("- %s: %s\n", prompt.Name, prompt.Description)
        
        if len(prompt.Arguments) > 0 {
            fmt.Printf("  Arguments:\n")
            for _, arg := range prompt.Arguments {
                fmt.Printf("    - %s: %s\n", arg.Name, arg.Description)
            }
        }
    }

    // Use a specific prompt
    if len(prompts.Prompts) > 0 {
        prompt := prompts.Prompts[0]
        fmt.Printf("\nUsing prompt: %s\n", prompt.Name)

        result, err := getPrompt(ctx, c, prompt.Name, map[string]interface{}{
            // Add appropriate arguments based on prompt schema
        })
        if err != nil {
            log.Printf("Failed to get prompt: %v", err)
            return
        }

        fmt.Printf("Prompt result:\n")
        fmt.Printf("Description: %s\n", result.Description)
        fmt.Printf("Messages: %d\n", len(result.Messages))
        
        for i, message := range result.Messages {
            fmt.Printf("Message %d (%s): %s\n", i+1, message.Role, message.Content.Text)
        }
    }
}
```

----------------------------------------

TITLE: List All Resources with MCP Go Client
DESCRIPTION: This Go function demonstrates how to list all available resources from an MCP server using the `mcp-go` client. It iterates through the returned resources, printing their URI, MIME type, name, and description.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_0

LANGUAGE: go
CODE:
```
import (
    "base64"
    "context"
    "encoding/json"
    "fmt"
    "log"
    "reflect"
    "regexp"
    "strings"
    "sync"
    "time"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

func listResources(ctx context.Context, c client.Client) error {
    // List all available resources
    resources, err := c.ListResources(ctx)
    if err != nil {
        return fmt.Errorf("failed to list resources: %w", err)
    }

    fmt.Printf("Available resources: %d\n", len(resources.Resources))
    for _, resource := range resources.Resources {
        fmt.Printf("- %s (%s): %s\n", 
            resource.URI, 
            resource.MIMEType, 
            resource.Name)
        
        if resource.Description != "" {
            fmt.Printf("  Description: %s\n", resource.Description)
        }
    }

    return nil
}
```

----------------------------------------

TITLE: Adding Session-Aware Tool Handler in MCP Go
DESCRIPTION: This Go snippet demonstrates how to add a session-aware tool handler to an MCP server. It retrieves the current client session from the context to personalize responses, returning an error if no session is active. This is crucial for tools requiring user-specific data.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_14

LANGUAGE: Go
CODE:
```
s.AddTool(mcp.NewTool("session_aware"), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Get the current session from context
    session := server.ClientSessionFromContext(ctx)
    if session == nil {
        return mcp.NewToolResultError("No active session"), nil
    }
    
    return mcp.NewToolResultText("Hello, session " + session.SessionID()), nil
})
```

----------------------------------------

TITLE: Handle Get User Tool Request in MCP-Go
DESCRIPTION: This function implements the `handleGetUser` logic, which processes requests for the `get_user` tool. It extracts the `user_id` parameter from the incoming request, performs validation to ensure the ID is provided, simulates a database lookup for the user, and returns the user's information as a formatted JSON string within a `CallToolResultText`.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_1

LANGUAGE: Go
CODE:
```
func handleGetUser(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    userID := req.GetString("user_id", "")
    if userID == "" {
        return nil, fmt.Errorf("user_id is required")
    }
    
    // Simulate database lookup
    user, err := getUserFromDB(userID)
    if err != nil {
        return nil, fmt.Errorf("user not found: %s", userID)
    }

    return mcp.NewToolResultText(fmt.Sprintf(`{"id":"%s","name":"%s","email":"%s","age":%d}`, 
        user.ID, user.Name, user.Email, user.Age)), nil
}
```

----------------------------------------

TITLE: Add panic recovery to MCP server in Go
DESCRIPTION: Demonstrates how to integrate automatic panic recovery into an MCP server using `server.WithRecovery()` to prevent crashes and return proper error responses.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_3

LANGUAGE: Go
CODE:
```
s := server.NewMCPServer(
    "Robust Server",
    "1.0.0", 
    server.WithRecovery(), // Automatically recover from panics
)
```

----------------------------------------

TITLE: Go Client Dynamic Prompt Generation Examples
DESCRIPTION: This snippet illustrates how to dynamically generate prompts for specific applications like code review and data analysis. It leverages the `PromptProcessor` to fetch and populate prompt templates with varying arguments based on the desired use case, demonstrating flexibility in prompt construction.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_10

LANGUAGE: go
CODE:
```
func generateCodeReviewPrompt(ctx context.Context, c client.Client, code, language string) ([]mcp.PromptMessage, error) {
    processor := NewPromptProcessor(c)
    
    return processor.ProcessPrompt(ctx, "code_review", map[string]interface{}{
        "code":     code,
        "language": language,
        "focus":    "best-practices",
    })
}

func generateDataAnalysisPrompt(ctx context.Context, c client.Client, datasetURI string, analysisType string) ([]mcp.PromptMessage, error) {
    processor := NewPromptProcessor(c)
    
    return processor.ProcessPrompt(ctx, "analyze_data", map[string]interface{}{
        "dataset_uri":   datasetURI,
        "analysis_type": analysisType,
        "focus_areas":   []string{"trends", "outliers", "correlations"},
    })
}

func demonstrateDynamicPrompts(ctx context.Context, c client.Client) {
    // Generate code review prompt
    codeReviewMessages, err := generateCodeReviewPrompt(ctx, c, 
        "func main() { fmt.Println(\"Hello\") }", 
        "go")
    if err != nil {
        log.Printf("Failed to generate code review prompt: %v", err)
    } else {
        fmt.Printf("Code review prompt: %d messages\n", len(codeReviewMessages))
    }

    // Generate data analysis prompt
    analysisMessages, err := generateDataAnalysisPrompt(ctx, c, 
        "dataset://sales_data", 
        "exploratory")
    if err != nil {
        log.Printf("Failed to generate analysis prompt: %v", err)
    } else {
        fmt.Printf("Data analysis prompt: %d messages\n", len(analysisMessages))
    }
}
```

----------------------------------------

TITLE: Define MCP Tools in Go
DESCRIPTION: Tools provide functionality for LLMs to invoke actions or computations, akin to POST endpoints. They are action-oriented, accept parameterized inputs with typed schemas, and return structured results. This example shows how to define a simple arithmetic calculation tool and a file creation tool.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_1

LANGUAGE: go
CODE:
```
// Simple calculation tool
calcTool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform arithmetic operations"),
    mcp.WithString("operation", 
        mcp.Required(),
        mcp.Enum("add", "subtract", "multiply", "divide"),
    ),
    mcp.WithNumber("x", mcp.Required()),
    mcp.WithNumber("y", mcp.Required()),
)

// File creation tool
fileTool := mcp.NewTool("create_file",
    mcp.WithDescription("Create a new file with content"),
    mcp.WithString("path", mcp.Required()),
    mcp.WithString("content", mcp.Required()),
    mcp.WithString("encoding", mcp.Default("utf-8")),
)
```

----------------------------------------

TITLE: Define an MCP Tool for Arithmetic Operations in Go
DESCRIPTION: Example of defining a 'calculate' tool using `mcp.NewTool` with a description, required string parameter for operation (enum: add, subtract, multiply, divide), and two required number parameters (x, y).
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_3

LANGUAGE: go
CODE:
```
calculatorTool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform basic arithmetic operations"),
    mcp.WithString("operation",
        mcp.Required(),
        mcp.Enum("add", "subtract", "multiply", "divide"),
    ),
    mcp.WithNumber("x", mcp.Required()),
    mcp.WithNumber("y", mcp.Required()),
)
```

----------------------------------------

TITLE: Define a Basic Tool in Go
DESCRIPTION: This Go code demonstrates how to create a simple tool named 'calculate' using `mcp.NewTool`. It defines parameters for an arithmetic operation (enum: add, subtract, multiply, divide) and two numbers (x, y), all marked as required, ensuring type-safe and validated inputs for the LLM.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_0

LANGUAGE: go
CODE:
```
// Create a simple tool
tool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform arithmetic operations"),
    mcp.WithString("operation", 
        mcp.Required(),
        mcp.Enum("add", "subtract", "multiply", "divide"),
        mcp.Description("The arithmetic operation to perform"),
    ),
    mcp.WithNumber("x", mcp.Required(), mcp.Description("First number")),
    mcp.WithNumber("y", mcp.Required(), mcp.Description("Second number")),
)
```

----------------------------------------

TITLE: Create a Basic MCP Resource in Go
DESCRIPTION: This snippet demonstrates how to create a fundamental MCP resource using `mcp.NewResource`. It defines the URI, a human-readable name, a description, and the MIME type for the resource, preparing it for exposure to LLMs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_0

LANGUAGE: go
CODE:
```
// Create a simple resource
resource := mcp.NewResource(
    "docs://readme",           // URI - unique identifier
    "Project README",          // Name - human-readable
    mcp.WithResourceDescription("Main project documentation"),
    mcp.WithMIMEType("text/markdown"),
)
```

----------------------------------------

TITLE: Adding Custom HTTP Endpoints to MCP Go Server
DESCRIPTION: Demonstrates how to integrate custom HTTP routes alongside the standard MCP endpoints within a Go StreamableHTTP server. It shows the main function setting up the server, adding MCP routes, and then defining handlers for custom API paths like /api/status, /api/metrics, and /api/users, including basic examples of handler functions.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_7

LANGUAGE: go
CODE:
```
func main() {
    s := server.NewMCPServer("Custom StreamableHTTP Server", "1.0.0")
    
    // Create HTTP server with custom routes
    mux := http.NewServeMux()
    
    // Add MCP endpoints
    server.AddMCPRoutes(mux, s, "/mcp")
    
    // Add custom endpoints
    mux.HandleFunc("/api/status", handleStatus)
    mux.HandleFunc("/api/metrics", handleMetrics)
    mux.HandleFunc("/api/users", handleUsersAPI)
    mux.HandleFunc("/api/upload", handleFileUpload)
    
    // Add middleware
    handler := addMiddleware(mux)
    
    log.Println("Starting custom StreamableHTTP server on :8080")
    if err := http.ListenAndServe(":8080", handler); err != nil {
        log.Fatal(err)
    }
}

func handleStatus(w http.ResponseWriter, r *http.Request) {
    status := map[string]interface{}{
        "status":    "healthy",
        "timestamp": time.Now().Unix(),
        "version":   "1.0.0",
        "uptime":    time.Since(startTime).String()
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(status)
}

func handleMetrics(w http.ResponseWriter, r *http.Request) {
    metrics := collectMetrics()
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(metrics)
}

func handleUsersAPI(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        handleListUsers(w, r)
    case "POST":
        handleCreateUserAPI(w, r)
    case "PUT":
        handleUpdateUser(w, r)
    case "DELETE":
        handleDeleteUser(w, r)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

----------------------------------------

TITLE: Go Function for Environment-Based Transport Selection
DESCRIPTION: This Go function illustrates how to encapsulate the logic for starting an MCP server with different transports (SSE, StreamableHTTP, In-Process, or STDIO) based on the 'MCP_TRANSPORT' environment variable. It also includes a helper to get the port.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/index.mdx#_snippet_1

LANGUAGE: go
CODE:
```
func startServer(s *server.MCPServer) error {
    switch os.Getenv("MCP_TRANSPORT") {
    case "sse":
        sseServer := server.NewSSEServer(s)
        return sseServer.Start(getPort())
    case "streamablehttp":
        httpServer := server.NewStreamableHTTPServer(s)
        return httpServer.Start(getPort())
    case "inprocess":
        // Note: In-process transport doesn't use network ports
        // This would typically be used differently in practice
        client := client.NewInProcessClient(s)
        defer client.Close()
        // Keep the process running
        select {}
    default:
        return server.ServeStdio(s)
    }
}

func getPort() string {
    if port := os.Getenv("PORT"); port != "" {
        return ":" + port
    }
    return ":8080"
}
```

----------------------------------------

TITLE: Initialize MCP Go Client with Custom Details
DESCRIPTION: This Go function demonstrates how to initialize an MCP client connection. It sends an `InitializeRequest` with a specified protocol version, client capabilities (Tools, Resources, Prompts), and custom client information like name and version. The function then logs the server's information and capabilities upon successful connection.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
func initializeClientWithDetails(ctx context.Context, c client.Client) error {
    // Initialize with custom client info
    initReq := mcp.InitializeRequest{
        Params: mcp.InitializeRequestParams{
            ProtocolVersion: "2024-11-05",
            Capabilities: mcp.ClientCapabilities{
                Tools:     &mcp.ToolsCapability{},
                Resources: &mcp.ResourcesCapability{},
                Prompts:   &mcp.PromptsCapability{},
            },
            ClientInfo: mcp.ClientInfo{
                Name:    "My Application",
                Version: "1.0.0",
            },
        },
    }

    result, err := c.InitializeWithRequest(ctx, initReq)
    if err != nil {
        return fmt.Errorf("initialization failed: %w", err)
    }

    log.Printf("Connected to server: %s v%s", 
        result.ServerInfo.Name, 
        result.ServerInfo.Version)
    
    log.Printf("Server capabilities: %+v", result.Capabilities)

    return nil
}
```

----------------------------------------

TITLE: StreamableHTTP Authentication
DESCRIPTION: Demonstrates how to create a StreamableHTTP client with OAuth 2.0 authentication using `transport.WithHTTPOAuth`. It also includes a utility function `isAuthError` to check for common authentication-related errors like `ErrUnauthorized` or `ErrForbidden`.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_6

LANGUAGE: go
CODE:
```
func createAuthenticatedStreamableHTTPClient() {
    // Create StreamableHTTP client with OAuth
    c := client.NewStreamableHttpClient("http://localhost:8080/mcp",
        transport.WithHTTPOAuth(transport.OAuthConfig{
            ClientID:     "your-client-id",
            ClientSecret: "your-client-secret",
            TokenURL:     "https://auth.example.com/token",
            Scopes:       []string{"mcp:read", "mcp:write"},
        }),
    )
    defer c.Close()

    ctx := context.Background()

    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Use client...
}

func isAuthError(err error) bool {
    return errors.Is(err, ErrUnauthorized) ||
           errors.Is(err, ErrForbidden)
}
```

----------------------------------------

TITLE: Define MCP Resources in Go
DESCRIPTION: Resources expose read-only data to LLMs, similar to GET endpoints. They are URI-based, have typed content, and can be dynamic or static. This snippet demonstrates creating both a static resource and a dynamic, templated user profile resource.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_0

LANGUAGE: go
CODE:
```
// Static resource
resource := mcp.NewResource(
    "docs://readme",
    "Project README",
    mcp.WithResourceDescription("The project's main documentation"),
    mcp.WithMIMEType("text/markdown"),
)

// Dynamic resource with template
userResource := mcp.NewResource(
    "users://{user_id}",
    "User Profile",
    mcp.WithResourceDescription("User profile information"),
    mcp.WithMIMEType("application/json"),
)
```

----------------------------------------

TITLE: Start MCP server with HTTP transport in Go
DESCRIPTION: Demonstrates how to create and start an MCP server with an HTTP transport, ideal for web services and load-balanced deployments. It uses `server.NewStreamableHTTPServer()` and `httpServer.Start()`.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_6

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("HTTP Server", "1.0.0")
    
    // Create HTTP server
    httpServer := server.NewStreamableHTTPServer(s)
    
    // Start HTTP server on port 8080
    if err := httpServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}
```

----------------------------------------

TITLE: Defining a Basic MCP Prompt in Go
DESCRIPTION: This snippet illustrates the fundamental structure for creating a prompt using `mcp.NewPrompt`. It shows how to define a prompt name, add a description, and specify arguments with their requirements and default values, such as 'code' and 'language'.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_0

LANGUAGE: go
CODE:
```
// Create a simple prompt
prompt := mcp.NewPrompt("code_review",
    mcp.WithPromptDescription("Review code for best practices and issues"),
    mcp.WithPromptArgument("code",
        mcp.Required(),
        mcp.Description("The code to review"),
    ),
    mcp.WithPromptArgument("language",
        mcp.Description("Programming language"),
        mcp.Default("auto-detect"),
    ),
)
```

----------------------------------------

TITLE: Go: Demonstrate MCP Client Lifecycle
DESCRIPTION: Illustrates the complete lifecycle of an MCP client, from creation and initialization to operation (listing and calling tools) and proper cleanup using defer.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_4

LANGUAGE: go
CODE:
```
func demonstrateClientLifecycle() error {
    // 1. Creation
    c, err := client.NewSSEMCPClient("server-command")
    if err != nil {
        return fmt.Errorf("client creation failed: %w", err)
    }

    // Ensure cleanup happens
    defer func() {
        if closeErr := c.Close(); closeErr != nil {
            log.Printf("Error closing client: %v", closeErr)
        }
    }()

    ctx := context.Background()

    // 2. Initialization
    if err := c.Initialize(ctx); err != nil {
        return fmt.Errorf("client initialization failed: %w", err)
    }

    // 3. Operation
    if err := performClientOperations(ctx, c); err != nil {
        return fmt.Errorf("client operations failed: %w", err)
    }

    // 4. Cleanup (handled by defer)
    return nil
}

func performClientOperations(ctx context.Context, c client.Client) error {
    // List available tools
    tools, err := c.ListTools(ctx)
    if err != nil {
        return err
    }

    log.Printf("Found %d tools", len(tools.Tools))

    // Use the tools
    for _, tool := range tools.Tools {
        result, err := c.CallTool(ctx, mcp.CallToolRequest{
            Params: mcp.CallToolRequestParams{
                Name:      tool.Name,
                Arguments: map[string]interface{}{
                    "input": "example input",
                    "format": "json",
                },
            },
        })
        if err != nil {
            log.Printf("Tool %s failed: %v", tool.Name, err)
            continue
        }

        log.Printf("Tool %s result: %+v", tool.Name, result)
    }

    return nil
}
```

----------------------------------------

TITLE: Start MCP server with SSE transport in Go
DESCRIPTION: Illustrates how to configure and start an MCP server using Server-Sent Events (SSE) for real-time updates, suitable for web applications and browser-based tools. It uses `server.NewSSEServer()` and `sseServer.Start()`.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_7

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("SSE Server", "1.0.0")
    
    // Create SSE server
    sseServer := server.NewSSEServer(s)
    
    // Start SSE server on port 8080
    if err := sseServer.Start(":8080"); err != nil {
        log.Fatal(err)
    }
}
```

----------------------------------------

TITLE: Implement Common Error Handling Patterns in Go MCP Server
DESCRIPTION: This Go function illustrates robust error handling for resource access within an MCP server. It includes validation for URI format, permission checks, and handling for 'resource not found' and general fetch errors.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_10

LANGUAGE: go
CODE:
```
func handleResourceWithErrors(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    // Validate URI format
    if !isValidURI(req.Params.URI) {
        return nil, fmt.Errorf("invalid URI format: %s", req.Params.URI)
    }
    
    // Check permissions
    if !hasPermission(ctx, req.Params.URI) {
        return nil, fmt.Errorf("access denied to resource: %s", req.Params.URI)
    }
    
    // Handle resource not found
    data, err := fetchResourceData(req.Params.URI)
    if err != nil {
        if errors.Is(err, ErrResourceNotFound) {
            return nil, fmt.Errorf("resource not found: %s", req.Params.URI)
        }
        return nil, fmt.Errorf("failed to fetch resource: %w", err)
    }
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContents{
            mcp.TextResourceContents{
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(jsonData),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Apply Enums and Constraints to Go Tool Parameters
DESCRIPTION: This Go code shows how to enforce specific values using enums and apply regular expression patterns for string validation, such as for email addresses. It also demonstrates setting minimum and exclusive maximum constraints for number parameters, ensuring data integrity and adherence to business rules.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_2

LANGUAGE: go
CODE:
```
// Enum values
mcp.WithString("priority",
    mcp.Required(),
    mcp.Enum("low", "medium", "high", "critical"),
    mcp.Description("Task priority level"),
)

// String constraints
mcp.WithString("email",
    mcp.Required(),
    mcp.Pattern(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`),
    mcp.Description("Valid email address"),
)

// Number constraints
mcp.WithNumber("price",
    mcp.Required(),
    mcp.Minimum(0),
    mcp.ExclusiveMaximum(10000),
    mcp.Description("Product price in USD"),
)
```

----------------------------------------

TITLE: Handle Create User Tool Request in MCP-Go
DESCRIPTION: This function, `handleCreateUser`, processes requests to create a new user. It retrieves `name`, `email`, and `age` parameters from the tool request, validates that required fields are present and the email format is valid. It then simulates the creation and saving of a new user to a database, returning a success message with the newly created user's details.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_2

LANGUAGE: Go
CODE:
```
func handleCreateUser(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    name := req.GetString("name", "")
    email := req.GetString("email", "")
    age := req.GetInt("age", 0)

    if name == "" || email == "" {
        return nil, fmt.Errorf("name and email are required")
    }

    // Validate input
    if !isValidEmail(email) {
        return nil, fmt.Errorf("invalid email format: %s", email)
    }

    // Create user
    user := &User{
        ID:        generateID(),
        Name:      name,
        Email:     email,
        Age:       age,
        CreatedAt: time.Now(),
    }

    if err := saveUserToDB(user); err != nil {
        return nil, fmt.Errorf("failed to create user: %w", err)
    }

    return mcp.NewToolResultText(fmt.Sprintf(`{"id":"%s","message":"User created successfully","user":{"id":"%s","name":"%s","email":"
```

----------------------------------------

TITLE: Handle STDIO Client Errors in Go
DESCRIPTION: Illustrates common error handling patterns for STDIO clients in Go, specifically addressing ErrProcessExited, ErrProcessTimeout, and ErrBrokenPipe. It shows how to attempt restarts or kill/restart the process based on the error type.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_1

LANGUAGE: go
CODE:
```
// Define error constants for STDIO client errors
var (
    ErrProcessExited  = errors.New("process exited")
    ErrProcessTimeout = errors.New("process timeout")
    ErrBrokenPipe     = errors.New("broken pipe")
)

func handleStdioErrors(c *client.StdioClient) {
    ctx := context.Background()

    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "example_tool",
        },
    })

    if err != nil {
        switch {
        case errors.Is(err, ErrProcessExited):
            log.Println("Server process exited unexpectedly")
            // Attempt to restart
            if restartErr := c.Restart(); restartErr != nil {
                log.Printf("Failed to restart: %v", restartErr)
            }

        case errors.Is(err, ErrProcessTimeout):
            log.Println("Server process timed out")
            // Kill and restart process
            c.Kill()
            if restartErr := c.Restart(); restartErr != nil {
                log.Printf("Failed to restart: %v", restartErr)
            }

        case errors.Is(err, ErrBrokenPipe):
            log.Println("Communication pipe broken")
            // Process likely crashed, restart
            if restartErr := c.Restart(); restartErr != nil {
                log.Printf("Failed to restart: %v", restartErr)
            }

        default:
            log.Printf("Unexpected error: %v", err)
        }
        return
    }

    log.Printf("Tool result: %+v", result)
}
```

----------------------------------------

TITLE: Handle MCP-Go Client Errors
DESCRIPTION: This example demonstrates robust error handling for `mcp-go` tool calls. It uses `errors.Is` to identify specific client errors like connection loss, tool not found, or invalid arguments, allowing for tailored responses such as reconnection attempts or logging.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_6

LANGUAGE: Go
CODE:
```
func handleClientErrors(ctx context.Context, c client.Client) {
    // Tool call with error handling
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "example_tool",
            Arguments: map[string]interface{}{
                "param": "value",
            },
        },
    })

    if err != nil {
        switch {
        case errors.Is(err, client.ErrConnectionLost):
            log.Println("Connection lost, attempting reconnect...")
            // Implement reconnection logic
        case errors.Is(err, client.ErrToolNotFound):
            log.Printf("Tool not found: %v", err)
        case errors.Is(err, client.ErrInvalidArguments):
            log.Printf("Invalid arguments: %v", err)
        default:
            log.Printf("Unexpected error: %v", err)
        }
        return
    }

    // Process successful result
    processToolResult(result)
}
```

----------------------------------------

TITLE: Call and List External Tools in Go
DESCRIPTION: This Go example demonstrates how to interact with external tools via a client.Client. It includes a callTool function for invoking a named tool with specific arguments and a demonstrateToolCalling function that lists available tools and then calls the first one found, printing its output. This showcases the basic pattern for integrating and utilizing external functionalities.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_5

LANGUAGE: go
CODE:
```
func callTool(ctx context.Context, c client.Client, name string, args map[string]interface{}) (*mcp.CallToolResult, error) {
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name:      name,
            Arguments: args,
        },
    })
    if err != nil {
        return nil, fmt.Errorf("tool call failed: %w", err)
    }

    return result, nil
}

func demonstrateToolCalling(ctx context.Context, c client.Client) {
    // List available tools
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Printf("Failed to list tools: %v", err)
        return
    }

    fmt.Printf("Available tools: %d\n", len(tools.Tools))
    for _, tool := range tools.Tools {
        fmt.Printf("- %s: %s\n", tool.Name, tool.Description)
    }

    // Call a specific tool
    if len(tools.Tools) > 0 {
        tool := tools.Tools[0]
        fmt.Printf("\nCalling tool: %s\n", tool.Name)

        result, err := callTool(ctx, c, tool.Name, map[string]interface{}{
            "input": "example input",
            "format": "text",
        })
        if err != nil {
            log.Printf("Tool call failed: %v", err)
            return
        }

        fmt.Printf("Tool result:\n")
        for i, content := range result.Content {
            fmt.Printf("Content %d (%s): %s\n", i+1, content.Type, content.Text)
        }
    }
}
```

----------------------------------------

TITLE: Handle JSON Tool Results in Go
DESCRIPTION: This Go function demonstrates how to process a tool request and return a structured JSON result. It marshals a Go map into a JSON string and wraps it in an mcp.CallToolResult.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_12

LANGUAGE: go
CODE:
```
func handleJSONTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    result := map[string]interface{}{
        "status":    "success",
        "timestamp": time.Now().Unix(),
        "data": map[string]interface{}{
            "processed": 42,
            "errors":    0,
        },
    }
    
    jsonData, err := json.Marshal(result)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}
```

----------------------------------------

TITLE: MCP-Go Server Transport Layer Selection
DESCRIPTION: This Go snippet demonstrates the flexibility of the MCP-Go transport layer, allowing the same server instance to be served over different communication protocols like stdio, HTTP, or SSE. This abstraction simplifies development by handling serialization and connection management automatically.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_6

LANGUAGE: go
CODE:
```
// Same server works with any transport
s := server.NewMCPServer("My Server", "1.0.0")

// Choose transport at runtime
switch transport {
case "stdio":
    server.ServeStdio(s)
case "http":
    server.ServeHTTP(s, ":8080")
case "sse":
    server.ServeSSE(s, ":8080")
}
```

----------------------------------------

TITLE: Define Complex Typed Tool for User Creation in Go
DESCRIPTION: This Go snippet illustrates a more complex typed tool for user creation. It defines `UserCreateInput` and `UserCreateOutput` structs with extensive validation tags for various data types including strings, integers, slices, and maps. The `handleCreateUser` function shows how automatic validation simplifies handler logic, allowing direct focus on business logic like database interaction and user object creation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_1

LANGUAGE: go
CODE:
```
type UserCreateInput struct {
    Name     string            `json:"name" validate:"required,min=1,max=100"`
    Email    string            `json:"email" validate:"required,email"`
    Age      int               `json:"age" validate:"min=0,max=150"`
    Tags     []string          `json:"tags" validate:"dive,min=1"`
    Metadata map[string]string `json:"metadata"`
    Active   bool              `json:"active"`
}

type UserCreateOutput struct {
    ID        string    `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
    Status    string    `json:"status"`
}

func handleCreateUser(ctx context.Context, req mcp.CallToolRequest, input UserCreateInput) (*mcp.CallToolResult, error) {
    // Validation is automatic based on struct tags
    
    // Create user in database
    user := &User{
        ID:        generateID(),
        Name:      input.Name,
        Email:     input.Email,
        Age:       input.Age,
        Tags:      input.Tags,
        Metadata:  input.Metadata,
        Active:    input.Active,
        CreatedAt: time.Now(),
    }

    if err := db.Create(user); err != nil {
        return nil, fmt.Errorf("failed to create user: %w", err)
    }

    output := &UserCreateOutput{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
        Status:    "created",
    }

    return mcp.NewToolResultJSON(output), nil
}
```

----------------------------------------

TITLE: Send Notifications to Specific or All Go Client Sessions
DESCRIPTION: This Go snippet shows how to send notifications to client sessions managed by the SSE server. It provides examples for sending a notification to the current client session using `SendNotificationToClient` and notes the possibility of broadcasting to all connected clients, depending on the server's implementation. This is crucial for targeted or broad real-time updates.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/sse.mdx#_snippet_4

LANGUAGE: go
CODE:
```
// Send notification to current client session
mcpServer.SendNotificationToClient(ctx, "progress_update", progressData)

// Send notification to all connected clients (if supported)
// Note: Check the server implementation for broadcast capabilities
```

----------------------------------------

TITLE: Implement MCP Transports in Go
DESCRIPTION: Transports define the communication methods between MCP clients and servers, with MCP-Go supporting various options for different deployment scenarios. This code demonstrates how to serve an MCP server using Stdio (standard I/O), HTTP, and Server-Sent Events (SSE) transports.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// Stdio transport (most common)
server.ServeStdio(s)

// HTTP transport
server.ServeHTTP(s, ":8080")

// SSE transport
server.ServeSSE(s, ":8080")
```

----------------------------------------

TITLE: Run an MCP-Go Server
DESCRIPTION: Instructions to compile and execute the Go MCP server application from the command line.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
go run main.go
```

----------------------------------------

TITLE: Manage MCP-Go Client Connections
DESCRIPTION: This snippet defines `MCPClientManager` for managing `mcp-go` client connections. It includes `NewMCPClientManager` to initialize different client types (stdio, http, sse) and handles initial connection setup. The `Close` method ensures proper resource cleanup.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
import (
    "context"
    "errors"
    "fmt"
    "log"
    "sync"
    "time"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

type MCPClientManager struct {
    client client.Client
    ctx    context.Context
    cancel context.CancelFunc
}

func NewMCPClientManager(clientType, address string) (*MCPClientManager, error) {
    var c client.Client
    var err error

    switch clientType {
    case "stdio":
        c, err = client.NewStdioMCPClient("server-command")
    case "http":
        c = client.NewStreamableHttpClient(address)
    case "sse":
        c = client.NewSSEMCPClient(address)
    default:
        return nil, fmt.Errorf("unknown client type: %s", clientType)
    }

    if err != nil {
        return nil, err
    }

    ctx, cancel := context.WithCancel(context.Background())

    manager := &MCPClientManager{
        client: c,
        ctx:    ctx,
        cancel: cancel,
    }

    // Initialize connection
    if err := c.Initialize(ctx); err != nil {
        cancel()
        return nil, fmt.Errorf("failed to initialize client: %w", err)
    }

    return manager, nil
}

func (m *MCPClientManager) Close() error {
    m.cancel()
    return m.client.Close()
}
```

----------------------------------------

TITLE: Go: Create SSE MCP Client
DESCRIPTION: Provides an example of creating an SSE (Server-Sent Events) client, including how to set custom headers for the connection.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_3

LANGUAGE: go
CODE:
```
func createSSEClient() client.Client {
    // Basic SSE client
	c, err := NewSSEMCPClient(testServer.URL+"/sse",
		// Set custom headers
		WithHeaders(map[string]string{
			"X-Custom-Header": "custom-value",
			"Y-Another-Header": "another-value",
		}),
	)
    return c
}
```

----------------------------------------

TITLE: Implement Permission-Based Tool Filtering in Go
DESCRIPTION: This Go snippet provides a `PermissionFilter` struct that dynamically filters a list of tools based on the permissions associated with a user's session. It retrieves session information and checks if the session has the necessary permissions for each tool, allowing conditional exposure of functionalities. Tools without specific permission requirements are allowed by default.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_10

LANGUAGE: Go
CODE:
```
type PermissionFilter struct {
    sessionManager *SessionManager
}

func NewPermissionFilter(sm *SessionManager) *PermissionFilter {
    return &PermissionFilter{sessionManager: sm}
}

func (f *PermissionFilter) FilterTools(ctx context.Context, tools []mcp.Tool) []mcp.Tool {
    sessionID := server.GetSessionID(ctx)
    session, exists := f.sessionManager.GetSession(sessionID)
    if !exists {
        return []mcp.Tool{} // No tools for invalid sessions
    }

    var filtered []mcp.Tool
    for _, tool := range tools {
        if f.hasPermissionForTool(session, tool.Name) {
            filtered = append(filtered, tool)
        }
    }
    
    return filtered
}

func (f *PermissionFilter) hasPermissionForTool(session *SessionState, toolName string) bool {
    requiredPermissions := map[string][]string{
        "delete_user":    {"admin"},
        "modify_system":  {"admin", "operator"},
        "read_data":      {"admin", "operator", "user"},
        "create_report":  {"admin", "operator", "user"},
    }
    
    required, exists := requiredPermissions[toolName]
    if !exists {
        return true // Allow tools without specific requirements
    }
    
    for _, permission := range session.Permissions {
        for _, req := range required {
            if permission == req {
                return true
            }
        }
    }
    
    return false
}
```

----------------------------------------

TITLE: Create Basic Go StreamableHTTP Client
DESCRIPTION: This Go function demonstrates the creation and basic usage of a `StreamableHTTPClient`. It initializes the client, lists available tools, and handles potential errors, showcasing a straightforward way to interact with an MCP server over HTTP.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_4

LANGUAGE: go
CODE:
```
func createStreamableHTTPClient() {
    // Create StreamableHTTP client
    c := client.NewStreamableHttpClient("http://localhost:8080/mcp")
    defer c.Close()

    ctx := context.Background()

    // Initialize
    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Use client
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Available tools: %d", len(tools.Tools))
}
```

----------------------------------------

TITLE: Create StreamableHTTP MCP Client in Go
DESCRIPTION: Example of creating a StreamableHTTP MCP client, ideal for web applications and microservices, by providing the server's HTTP endpoint.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_2

LANGUAGE: go
CODE:
```
// Create StreamableHTTP client
client := client.NewStreamableHttpClient("http://localhost:8080/mcp")
```

----------------------------------------

TITLE: Implement Debug Logging for Go MCP Server
DESCRIPTION: This Go code snippet demonstrates how to set up file-based debug logging for an MCP server. It initializes a logger that writes to 'mcp-server.log' and shows how to use it within a custom tool implementation to log tool-specific messages, aiding in server debugging.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_7

LANGUAGE: go
CODE:
```
func main() {
    // Setup debug logging
    logFile, err := os.OpenFile("mcp-server.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Fatal(err)
    }
    defer logFile.Close()

    logger := log.New(logFile, "[MCP] ", log.LstdFlags|log.Lshortfile)

    s := server.NewMCPServer("Debug Server", "1.0.0",
        server.WithToolCapabilities(true),
        server.WithLogging(),
    )

    // Add tools with debug logging
    s.AddTool(
        mcp.NewTool("debug_echo",
            mcp.WithDescription("Echo with debug logging"),
            mcp.WithString("message", mcp.Required()),
        ),
        func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            message := req.GetString("message", "")
            logger.Printf("Echo tool called with message: %s", message)
            return mcp.NewToolResultText(fmt.Sprintf("Echo: %s", message)), nil
        },
    )

    logger.Println("Starting STDIO server...")
    if err := server.ServeStdio(s); err != nil {
        logger.Printf("Server error: %v", err)
    }
}
```

----------------------------------------

TITLE: MCP-Go Server Automatic Session Management with Hooks
DESCRIPTION: This Go snippet shows how an MCP server automatically manages multiple concurrent client sessions. It demonstrates using OnSessionStart and OnSessionEnd hooks to log client connections and disconnections, highlighting the built-in support for session isolation and resource cleanup.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_7

LANGUAGE: go
CODE:
```
// Server automatically handles multiple sessions
s := server.NewMCPServer("Multi-Client Server", "1.0.0",
    server.WithHooks(&server.Hooks{
        OnSessionStart: func(sessionID string) {
            log.Printf("Client %s connected", sessionID)
        },
        OnSessionEnd: func(sessionID string) {
            log.Printf("Client %s disconnected", sessionID)
        },
    }),
)
```

----------------------------------------

TITLE: Configure MCP-Go Server Transport Options in Go
DESCRIPTION: Examples of setting up different transport methods for an MCP-Go server, including Stdio, Streamable HTTP, Server-Sent Events (SSE), and In-Process client connections.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_6

LANGUAGE: go
CODE:
```
server.ServeStdio(s)
server.NewStreamableHTTPServer(s).Start(":8080")
server.ServeSSE(s, ":8080")
client.NewInProcessClient(server)
```

----------------------------------------

TITLE: Go: Create STDIO MCP Client
DESCRIPTION: Illustrates how to create an STDIO MCP client, which spawns a subprocess. Includes examples for basic creation and creation with custom environment variables.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_1

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "errors"
    "fmt"
    "log"
    "math"
    "net/http"
    "sync"
    "time"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

func createStdioClient() (client.Client, error) {
    // Create client that spawns a subprocess
    c, err := client.NewStdioMCPClient(
        "go", []string{}, "run", "/path/to/server/main.go",
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create STDIO client: %w", err)
    }

    return c, nil
}

// With custom environment variables
func createStdioClientWithEnv() (client.Client, error) {
    env := []string{
        "LOG_LEVEL=debug",
        "DATABASE_URL=sqlite://test.db",
    }
    c, err := client.NewStdioMCPClient(
        "go", env, "run", "/path/to/server/main.go",
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create STDIO client: %w", err)
    }

    return c, nil
}
```

----------------------------------------

TITLE: Configure Go Server Transport and Port with Environment Variables
DESCRIPTION: This Go code demonstrates how to configure a server's transport protocol (HTTP, SSE, or stdio) and port based on environment variables. It reads MCP_TRANSPORT and PORT to dynamically select the server type and binding address, defaulting to port 8080 if not specified.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_9

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("Configurable Server", "1.0.0")
    
    // Choose transport based on environment
    transport := os.Getenv("MCP_TRANSPORT")
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    switch transport {
    case "http":
        httpServer := server.NewStreamableHTTPServer(s)
        httpServer.Start(":"+port)
    case "sse":
        sseServer := server.NewSSEServer(s)
        sseServer.Start(":"+port)
    default:
        server.ServeStdio(s)
    }
}
```

----------------------------------------

TITLE: Implement Basic Typed Tool for Arithmetic Operations in Go
DESCRIPTION: This Go code demonstrates how to create a basic typed tool using MCP-Go for performing arithmetic operations. It defines input and output structs (`CalculateInput`, `CalculateOutput`) with validation tags, registers a 'calculate' tool, and implements a typed handler (`handleCalculateTyped`) that automatically validates input and returns structured results. This reduces boilerplate and ensures type safety.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

// Define input and output types
type CalculateInput struct {
    Operation string  `json:"operation" validate:"required,oneof=add subtract multiply divide"`
    X         float64 `json:"x" validate:"required"`
    Y         float64 `json:"y" validate:"required"`
}

type CalculateOutput struct {
    Result    float64 `json:"result"`
    Operation string  `json:"operation"`
}

func main() {
    s := server.NewMCPServer("Typed Server", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // Create typed tool
    tool := mcp.NewTool("calculate",
        mcp.WithDescription("Perform arithmetic operations"),
        mcp.WithString("operation", mcp.Required()),
        mcp.WithNumber("x", mcp.Required()),
        mcp.WithNumber("y", mcp.Required()),
    )
    
    // Add tool with typed handler
    s.AddTool(tool, mcp.NewTypedToolHandler(handleCalculateTyped))

    server.ServeStdio(s)
}

func handleCalculateTyped(ctx context.Context, req mcp.CallToolRequest, input CalculateInput) (*mcp.CallToolResult, error) {
    var result float64
    
    switch input.Operation {
    case "add":
        result = input.X + input.Y
    case "subtract":
        result = input.X - input.Y
    case "multiply":
        result = input.X * input.Y
    case "divide":
        if input.Y == 0 {
            return mcp.NewToolResultError("division by zero"), nil
        }
        result = input.X / input.Y
    }

    output := CalculateOutput{
        Result:    result,
        Operation: input.Operation,
    }
    
    jsonData, err := json.Marshal(output)
    if err != nil {
        return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
    }
    
    return mcp.NewToolResultText(string(jsonData)), nil
}
```

----------------------------------------

TITLE: Create a StreamableHTTP MCP Client in Go
DESCRIPTION: This Go program demonstrates how to create an MCP client that connects to a StreamableHTTP-based MCP server. It initializes the connection and then calls a tool, showcasing interaction with HTTP-enabled MCP services.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_5

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

func main() {
    // Create a StreamableHTTP client
    c := client.NewStreamableHttpClient("http://localhost:8080/mcp")
    defer c.Close()

    ctx := context.Background()

    // Initialize and use the client
    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Call a tool
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "hello_world",
            Arguments: map[string]interface{}{
                "name": "StreamableHTTP World",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Tool result: %+v\n", result)
}
```

----------------------------------------

TITLE: Configure Claude Desktop for MCP-Go Server
DESCRIPTION: This JSON configuration snippet demonstrates how to integrate an MCP-Go server with Claude Desktop. It specifies the command and arguments required for Claude to launch and connect to your local MCP server.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_2

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "hello-world": {
      "command": "go",
      "args": ["run", "/path/to/your/hello-server/main.go"]
    }
  }
}
```

----------------------------------------

TITLE: Enable specific or all capabilities for MCP server in Go
DESCRIPTION: Illustrates how to enable specific capabilities (Tools, Resources, Prompts) or all of them for an MCP server using `server.WithToolCapabilities()`, `server.WithResourceCapabilities()`, and `server.WithPromptCapabilities()`.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_2

LANGUAGE: Go
CODE:
```
// Enable specific capabilities
s := server.NewMCPServer(
    "Specialized Server",
    "1.0.0",
    server.WithToolCapabilities(true),      // Can execute tools
    server.WithResourceCapabilities(true),  // Can provide resources
    server.WithPromptCapabilities(true),    // Can provide prompts
)

// Or enable all capabilities
s := server.NewMCPServer(
    "Full-Featured Server", 
    "1.0.0",
    server.WithToolCapabilities(true),
    server.WithResourceCapabilities(true),
    server.WithPromptCapabilities(true),
)
```

----------------------------------------

TITLE: Go Transport Selection Logic for MCP
DESCRIPTION: This Go code defines a `TransportRequirements` struct and a `SelectTransport` function that helps determine the optimal communication transport for an application based on specified criteria. It considers factors like real-time needs, multi-client support, network requirements, performance, and complexity to suggest transports such as 'inprocess', 'stdio', 'sse', or 'streamablehttp'. Usage examples illustrate how different requirement sets map to different transport recommendations.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_13

LANGUAGE: go
CODE:
```
type TransportRequirements struct {
    RealTime        bool
    MultiClient     bool
    NetworkRequired bool
    Performance     string // "high", "medium", "low"
    Complexity      string // "low", "medium", "high"
}

func SelectTransport(req TransportRequirements) string {
    switch {
    case !req.NetworkRequired && req.Performance == "high":
        return "inprocess"
    
    case !req.NetworkRequired && !req.MultiClient:
        return "stdio"
    
    case req.RealTime && req.MultiClient:
        return "sse"
    
    case req.NetworkRequired && req.MultiClient:
        return "streamablehttp"
    
    default:
        return "stdio" // Default fallback
    }
}

// Usage examples
func demonstrateTransportSelection() {
    // High-performance testing
    testReq := TransportRequirements{
        RealTime:        false,
        MultiClient:     false,
        NetworkRequired: false,
        Performance:     "high",
        Complexity:      "low",
    }
    fmt.Printf("Testing: %s\n", SelectTransport(testReq))

    // Real-time web application
    webReq := TransportRequirements{
        RealTime:        true,
        MultiClient:     true,
        NetworkRequired: true,
        Performance:     "medium",
        Complexity:      "medium",
    }
    fmt.Printf("Web app: %s\n", SelectTransport(webReq))

    // CLI tool
    cliReq := TransportRequirements{
        RealTime:        false,
        MultiClient:     false,
        NetworkRequired: false,
        Performance:     "medium",
        Complexity:      "low",
    }
    fmt.Printf("CLI tool: %s\n", SelectTransport(cliReq))
}
```

----------------------------------------

TITLE: Implement Comprehensive Telemetry Hooks in Go
DESCRIPTION: This Go snippet defines a `TelemetryHooks` struct and its methods to capture various application events like server start/stop, session lifecycle, tool calls, and resource reads. It integrates with a `MetricsCollector` and `log.Logger` to increment counters, record gauges, and log events, providing a comprehensive view of system activity and performance.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
type TelemetryHooks struct {
    metrics MetricsCollector
    logger  *log.Logger
}

func NewTelemetryHooks(metrics MetricsCollector, logger *log.Logger) *TelemetryHooks {
    return &TelemetryHooks{
        metrics: metrics,
        logger:  logger,
    }
}

func (h *TelemetryHooks) OnServerStart() {
    h.logger.Println("MCP Server starting")
    h.metrics.Increment("server.starts")
}

func (h *TelemetryHooks) OnServerStop() {
    h.logger.Println("MCP Server stopping")
    h.metrics.Increment("server.stops")
}

func (h *TelemetryHooks) OnSessionStart(sessionID string) {
    h.logger.Printf("Session started: %s", sessionID)
    h.metrics.Increment("sessions.started")
    h.metrics.Gauge("sessions.active", h.getActiveSessionCount())
}

func (h *TelemetryHooks) OnSessionEnd(sessionID string) {
    h.logger.Printf("Session ended: %s", sessionID)
    h.metrics.Increment("sessions.ended")
    h.metrics.Gauge("sessions.active", h.getActiveSessionCount())
}

func (h *TelemetryHooks) OnToolCall(sessionID, toolName string, duration time.Duration, err error) {
    h.metrics.Increment("tools.calls", map[string]string{
        "tool":    toolName,
        "session": sessionID,
    })
    h.metrics.Histogram("tools.duration", duration.Seconds(), map[string]string{
        "tool": toolName,
    })
    
    if err != nil {
        h.metrics.Increment("tools.errors", map[string]string{
            "tool": toolName,
        })
    }
}

func (h *TelemetryHooks) OnResourceRead(sessionID, uri string, duration time.Duration, err error) {
    h.metrics.Increment("resources.reads", map[string]string{
        "session": sessionID,
    })
    h.metrics.Histogram("resources.duration", duration.Seconds())
    
    if err != nil {
        h.metrics.Increment("resources.errors")
    }
}
```

----------------------------------------

TITLE: Go Server Setup with Multiple Transports
DESCRIPTION: This Go code demonstrates how to create a transport-agnostic MCP server and dynamically select a transport (SSE, StreamableHTTP, or STDIO) based on environment variables. It includes a simple 'echo' tool handler.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/index.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"
    "os"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
    "github.com/mark3labs/mcp-go/client"
)

func main() {
    // Create server (transport-agnostic)
    s := server.NewMCPServer("Multi-Transport Server", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // Add a simple tool
    s.AddTool(
        mcp.NewTool("echo",
            mcp.WithDescription("Echo back the input"),
            mcp.WithString("message", mcp.Required()),
        ),
        handleEcho,
    )

    // Choose transport based on environment
    transport := os.Getenv("MCP_TRANSPORT")
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    switch transport {
    case "sse":
        fmt.Printf("Starting SSE server on port %s\n", port)
        sseServer := server.NewSSEServer(s)
        sseServer.Start(":" + port)
    case "streamablehttp":
        fmt.Printf("Starting StreamableHTTP server on port %s\n", port)
        httpServer := server.NewStreamableHTTPServer(s)
        httpServer.Start(":" + port)
    default:
        fmt.Println("Starting STDIO server")
        server.ServeStdio(s)
    }
}

func handleEcho(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    message, err := req.RequireString("message")
    if err != nil {
        return nil, err
    }
    return mcp.NewToolResultText(fmt.Sprintf("Echo: %s", message)), nil
}
```

----------------------------------------

TITLE: Start MCP server with Stdio transport in Go
DESCRIPTION: Explains how to start an MCP server using the standard input/output (Stdio) transport, suitable for local development and CLI tools. The server blocks until terminated.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_5

LANGUAGE: Go
CODE:
```
func main() {
    s := server.NewMCPServer("My Server", "1.0.0")
    
    // Start stdio server (blocks until terminated)
    if err := server.ServeStdio(s); err != nil {
        log.Fatal(err)
    }
}
```

----------------------------------------

TITLE: Install and Run MCP Inspector for Debugging
DESCRIPTION: These commands facilitate the installation of the MCP Inspector globally via npm, followed by running your MCP server with the inspector. This setup provides a web interface for interactive testing and debugging of your MCP tools.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_3

LANGUAGE: bash
CODE:
```
# Install the MCP Inspector
npm install -g @modelcontextprotocol/inspector

# Run your server with the inspector
mcp-inspector go run main.go
```

----------------------------------------

TITLE: Basic In-Process MCP Server with Calculator Tool in Go
DESCRIPTION: This snippet demonstrates how to set up an in-process MCP server, add a 'calculate' tool with defined parameters (operation, x, y), and then create an in-process client to interact with this server. It shows the full lifecycle from server creation and tool registration to client initialization and tool invocation, handling the result extraction.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/inprocess.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
    "github.com/mark3labs/mcp-go/client"
)

func main() {
    // Create server
    s := server.NewMCPServer("Calculator Server", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // Add calculator tool
    s.AddTool(
        mcp.NewTool("calculate",
            mcp.WithDescription("Perform basic mathematical calculations"),
            mcp.WithString("operation", 
                mcp.Required(),
                mcp.Enum("add", "subtract", "multiply", "divide"),
                mcp.Description("The operation to perform"),
            ),
            mcp.WithNumber("x", mcp.Required(), mcp.Description("First number")),
            mcp.WithNumber("y", mcp.Required(), mcp.Description("Second number")),
        ),
        handleCalculate,
    )

    // Create in-process client
    mcpClient, err := client.NewInProcessClient(s)
    if err != nil {
        log.Fatal(err)
    }
    defer mcpClient.Close()

    ctx := context.Background()

    // Initialize
    _, err = mcpClient.Initialize(ctx, mcp.InitializeRequest{
        Params: mcp.InitializeRequestParams{
            ProtocolVersion: "2024-11-05",
            Capabilities: mcp.ClientCapabilities{
                Tools: &mcp.ToolsCapability{},
            },
            ClientInfo: mcp.Implementation{
                Name:    "test-client",
                Version: "1.0.0",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // Use the calculator
    result, err := mcpClient.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolParams{
            Name: "calculate",
            Arguments: map[string]interface{}{
                "operation": "add",
                "x":         10.0,
                "y":         5.0,
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // Extract text from the first content item
    if len(result.Content) > 0 {
        if textContent, ok := mcp.AsTextContent(result.Content[0]); ok {
            fmt.Printf("Result: %s\n", textContent.Text)
        }
    }
}

func handleCalculate(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    operation := req.GetString("operation", "")
    x := req.GetFloat("x", 0)
    y := req.GetFloat("y", 0)

    var result float64
    switch operation {
    case "add":
        result = x + y
    case "subtract":
        result = x - y
    case "multiply":
        result = x * y
    case "divide":
        if y == 0 {
            return mcp.NewToolResultError("division by zero"), nil
        }
        result = x / y
    default:
        return nil, fmt.Errorf("unknown operation: %s", operation)
    }

    return mcp.NewToolResultText(fmt.Sprintf("%.2f", result)), nil
}
```

----------------------------------------

TITLE: Handle Multi-Message Conversations in Go
DESCRIPTION: The `handleConversationPrompt` function constructs a sequence of prompt messages for different conversation scenarios, such as customer support or technical interviews. It extracts scenario and user role from the request parameters and returns a `GetPromptResult` with a predefined set of `PromptMessage`s, enabling structured multi-turn interactions.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_4

LANGUAGE: Go
CODE:
```
func handleConversationPrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    scenario := req.Params.Arguments["scenario"].(string)
    userRole := getStringArg(req.Params.Arguments, "user_role", "customer")
    
    var messages []mcp.PromptMessage
    
    switch scenario {
    case "customer_support":
        messages = []mcp.PromptMessage{
            {
                Role: "system",
                Content: mcp.NewTextContent("You are a helpful customer support representative. Be polite, professional, and solution-oriented."),
            },
            {
                Role: "user",
                Content: mcp.NewTextContent(fmt.Sprintf("I'm a %s with a question about your service.", userRole)),
            },
            {
                Role: "assistant", 
                Content: mcp.NewTextContent("Hello! I'm here to help. What can I assist you with today?"),
            },
            {
                Role: "user",
                Content: mcp.NewTextContent("Please continue the conversation based on the customer's needs."),
            },
        }
        
    case "technical_interview":
        messages = []mcp.PromptMessage{
            {
                Role: "system",
                Content: mcp.NewTextContent("You are conducting a technical interview. Ask thoughtful questions and provide constructive feedback."),
            },
            {
                Role: "user",
                Content: mcp.NewTextContent("Let's begin the technical interview. Please start with an appropriate question."),
            },
        }
    }
    
    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("%s conversation scenario", strings.Title(scenario)),
        Messages:    messages,
    }, nil
}
```

----------------------------------------

TITLE: Defining Static Resource in MCP Go
DESCRIPTION: This snippet demonstrates how to create a static resource in MCP Go. It uses `mcp.NewResource` to define a resource with a fixed URI ('docs://readme'), a description, and a MIME type. The associated handler function reads the content of 'README.md' and returns it as `mcp.TextResourceContents`, making a specific file available to LLMs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_4

LANGUAGE: Go
CODE:
```
// Static resource example - exposing a README file
resource := mcp.NewResource(
    "docs://readme",
    "Project README",
    mcp.WithResourceDescription("The project's README file"), 
    mcp.WithMIMEType("text/markdown"),
)

// Add resource with its handler
s.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    content, err := os.ReadFile("README.md")
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      "docs://readme",
            MIMEType: "text/markdown",
            Text:     string(content),
        },
    }, nil
})
```

----------------------------------------

TITLE: Perform Concurrent Batch Tool Calls in Go
DESCRIPTION: This Go code demonstrates how to execute multiple tool calls concurrently using goroutines and `sync.WaitGroup`. It defines `ToolCall` and `ToolResult` structs to manage inputs and outputs for batch operations. The `callToolsBatch` function orchestrates the concurrent calls, and `demonstrateBatchToolCalls` provides an example of its usage.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_7

LANGUAGE: go
CODE:
```
type ToolCall struct {
    Name      string
    Arguments map[string]interface{}
}

type ToolResult struct {
    Call   ToolCall
    Result *mcp.CallToolResult
    Error  error
}

func callToolsBatch(ctx context.Context, c client.Client, calls []ToolCall) []ToolResult {
    results := make([]ToolResult, len(calls))
    
    // Use goroutines for concurrent calls
    var wg sync.WaitGroup
    for i, call := range calls {
        wg.Add(1)
        go func(index int, toolCall ToolCall) {
            defer wg.Done()
            
            result, err := callTool(ctx, c, toolCall.Name, toolCall.Arguments)
            results[index] = ToolResult{
                Call:   toolCall,
                Result: result,
                Error:  err,
            }
        }(i, call)
    }
    
    wg.Wait()
    return results
}

func demonstrateBatchToolCalls(ctx context.Context, c client.Client) {
    calls := []ToolCall{
        {
            Name: "get_weather",
            Arguments: map[string]interface{}{
                "location": "New York",
            },
        },
        {
            Name: "get_weather",
            Arguments: map[string]interface{}{
                "location": "London",
            },
        },
        {
            Name: "calculate",
            Arguments: map[string]interface{}{
                "operation": "add",
                "x":         10,
                "y":         20,
            },
        },
    }

    results := callToolsBatch(ctx, c, calls);
    
    for i, result := range results {
        fmt.Printf("Call %d (%s):\n", i+1, result.Call.Name)
        if result.Error != nil {
            fmt.Printf("  Error: %v\n", result.Error)
        } else {
            fmt.Printf("  Success: %+v\n", result.Result)
        }
    }
}
```

----------------------------------------

TITLE: Serving Dynamic JSON Content with MCP-Go Resources
DESCRIPTION: Provides an example of an MCP-Go resource handler that generates and serves dynamic JSON content. It creates a Go map, marshals it into a JSON string, and sets the MIME type to 'application/json' for the resource content.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_7

LANGUAGE: Go
CODE:
```
func handleJSONResource(ctx context.Context, req mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    data := map[string]interface{}{
        "message": "Hello, World!",
        "timestamp": time.Now().Unix(),
        "status": "success",
    }
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    
    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: "application/json",
            Text:     string(jsonData),
        },
    }, nil
}
```

----------------------------------------

TITLE: Implement Template-Based Prompts in Go
DESCRIPTION: This Go code defines a PromptTemplate struct and a map of predefined templates (promptTemplates) for structured prompt generation, such as bug reports or feature requests. The handleTemplatePrompt function retrieves a specified template, substitutes its variables with provided values, and generates the final prompt content.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_7

LANGUAGE: go
CODE:
```
type PromptTemplate struct {
    Name        string
    Description string
    Template    string
    Variables   []string
}

var promptTemplates = map[string]PromptTemplate{
    "bug_report": {
        Name:        "Bug Report Analysis",
        Description: "Analyze a bug report and suggest solutions",
        Template: `Please analyze this bug report:

**Bug Description:** {{.description}}
**Steps to Reproduce:** {{.steps}}
**Expected Behavior:** {{.expected}}
**Actual Behavior:** {{.actual}}
**Environment:** {{.environment}}

Please provide:
1. Root cause analysis
2. Potential solutions
3. Prevention strategies
4. Priority assessment`,
        Variables: []string{"description", "steps", "expected", "actual", "environment"},
    },
    "feature_request": {
        Name:        "Feature Request Evaluation",
        Description: "Evaluate a feature request",
        Template: `Please evaluate this feature request:

**Feature:** {{.feature}}
**Use Case:** {{.use_case}}
**User Story:** {{.user_story}}
**Acceptance Criteria:** {{.criteria}}

Please assess:
1. Business value and impact
2. Technical feasibility
3. Implementation complexity
4. Potential risks and considerations`,
        Variables: []string{"feature", "use_case", "user_story", "criteria"},
    },
}

func handleTemplatePrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    templateName := req.Params.Arguments["template"].(string)
    variables := req.Params.Arguments["variables"].(map[string]interface{})

    template, exists := promptTemplates[templateName]
    if !exists {
        return nil, fmt.Errorf("unknown template: %s", templateName)
    }

    // Replace template variables
    content := template.Template
    for _, variable := range template.Variables {
        if value, exists := variables[variable]; exists {
            placeholder := fmt.Sprintf("{{.%s}}", variable)
            content = strings.ReplaceAll(content, placeholder, fmt.Sprintf("%v", value))
        }
    }

    return &mcp.GetPromptResult{
        Description: template.Description,
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(content),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Handle Conditional Prompts in Go
DESCRIPTION: This Go code snippet demonstrates how to create dynamic prompts based on various user-provided arguments such as user_level, topic, and include_examples. The handleConditionalPrompt function constructs a prompt string by adjusting its complexity and content according to these parameters, while getBoolArg is a helper for parsing boolean arguments.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_6

LANGUAGE: go
CODE:
```
func handleConditionalPrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    userLevel := getStringArg(req.Params.Arguments, "user_level", "beginner")
    topic := req.Params.Arguments["topic"].(string)
    includeExamples := getBoolArg(req.Params.Arguments, "include_examples", true)

    var prompt strings.Builder
    
    // Adjust complexity based on user level
    switch userLevel {
    case "beginner":
        prompt.WriteString(fmt.Sprintf("Please explain %s in simple terms suitable for someone new to the topic. ", topic))
        prompt.WriteString("Use clear language and avoid jargon. ")
    case "intermediate":
        prompt.WriteString(fmt.Sprintf("Please provide a detailed explanation of %s. ", topic))
        prompt.WriteString("Include technical details but ensure clarity. ")
    case "advanced":
        prompt.WriteString(fmt.Sprintf("Please provide an in-depth analysis of %s. ", topic))
        prompt.WriteString("Include advanced concepts, edge cases, and technical nuances. ")
    }

    if includeExamples {
        prompt.WriteString("Please include relevant examples and practical applications.")
    }

    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("%s explanation for %s level", topic, userLevel),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(prompt.String()),
            },
        },
    }, nil
}

func getBoolArg(args map[string]interface{}, key string, defaultValue bool) bool {
    if val, exists := args[key]; exists {
        if b, ok := val.(bool); ok {
            return b
        }
    }
    return defaultValue
}
```

----------------------------------------

TITLE: Go SSE Event Handler Implementation
DESCRIPTION: This Go code defines an `SSEEventHandler` struct for managing Server-Sent Events from an `mcp.SSEClient`. It provides methods to start and stop event processing, and to register specific callback functions for different notification types like progress, messages, and resource/tool updates. The handler uses goroutines to process notifications concurrently and a mutex for safe handler registration.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_10

LANGUAGE: go
CODE:
```
type SSEEventHandler struct {
    client      *client.SSEClient
    handlers    map[string][]func(mcp.Notification)
    mutex       sync.RWMutex
    ctx         context.Context
    cancel      context.CancelFunc
    wg          sync.WaitGroup
}

func NewSSEEventHandler(c *client.SSEClient) *SSEEventHandler {
    ctx, cancel := context.WithCancel(context.Background())

    return &SSEEventHandler{
        client:   c,
        handlers: make(map[string][]func(mcp.Notification)),
        ctx:      ctx,
        cancel:   cancel,
    }
}

func (seh *SSEEventHandler) Start() error {
    notifications, err := seh.client.Subscribe(seh.ctx)
    if err != nil {
        return err
    }

    seh.wg.Add(1)
    go func() {
        defer seh.wg.Done()
        
        for {
            select {
            case notification := <-notifications:
                seh.handleNotification(notification)
            case <-seh.ctx.Done():
                return
            }
        }
    }()

    return nil
}

func (seh *SSEEventHandler) Stop() {
    seh.cancel()
    seh.wg.Wait()
}

func (seh *SSEEventHandler) OnProgress(handler func(mcp.Notification)) {
    seh.addHandler("notifications/progress", handler)
}

func (seh *SSEEventHandler) OnMessage(handler func(mcp.Notification)) {
    seh.addHandler("notifications/message", handler)
}

func (seh *SSEEventHandler) OnResourceUpdate(handler func(mcp.Notification)) {
    seh.addHandler("notifications/resources/updated", handler)
}

func (seh *SSEEventHandler) OnToolUpdate(handler func(mcp.Notification)) {
    seh.addHandler("notifications/tools/updated", handler)
}

func (seh *SSEEventHandler) addHandler(method string, handler func(mcp.Notification)) {
    seh.mutex.Lock()
    defer seh.mutex.Unlock()
    
    seh.handlers[method] = append(seh.handlers[method], handler)
}

func (seh *SSEEventHandler) handleNotification(notification mcp.Notification) {
    seh.mutex.RLock()
    handlers := seh.handlers[notification.Method]
    seh.mutex.RUnlock()

    for _, handler := range handlers {
        go handler(notification)
    }
}
```

----------------------------------------

TITLE: Handle Flexible Prompt Arguments in Go
DESCRIPTION: This Go code demonstrates how to parse and utilize various types of prompt arguments (required, optional with defaults, arrays, and objects) from an `mcp.GetPromptRequest`. It includes helper functions `getStringArg` and `getStringSliceArg` for safe type assertion and default value assignment, enabling dynamic prompt generation based on user-defined parameters.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/prompts.mdx#_snippet_3

LANGUAGE: Go
CODE:
```
func handleFlexiblePrompt(ctx context.Context, req mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    // Required arguments
    task := req.Params.Arguments["task"].(string)
    
    // Optional arguments with defaults
    tone := getStringArg(req.Params.Arguments, "tone", "professional")
    length := getStringArg(req.Params.Arguments, "length", "medium")
    audience := getStringArg(req.Params.Arguments, "audience", "general")
    
    // Array arguments
    keywords := getStringSliceArg(req.Params.Arguments, "keywords", []string{})
    
    // Object arguments
    var constraints map[string]interface{}
    if c, exists := req.Params.Arguments["constraints"]; exists {
        constraints = c.(map[string]interface{})
    }

    // Build prompt based on parameters
    prompt := buildDynamicPrompt(task, tone, length, audience, keywords, constraints)
    
    return &mcp.GetPromptResult{
        Description: fmt.Sprintf("Generate %s content", task),
        Messages: []mcp.PromptMessage{
            {
                Role: "user",
                Content: mcp.NewTextContent(prompt),
            },
        },
    }, nil
}

func getStringArg(args map[string]interface{}, key, defaultValue string) string {
    if val, exists := args[key]; exists {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return defaultValue
}

func getStringSliceArg(args map[string]interface{}, key string, defaultValue []string) []string {
    if val, exists := args[key]; exists {
        if slice, ok := val.([]interface{}); ok {
            result := make([]string, len(slice))
            for i, v := range slice {
                if str, ok := v.(string); ok {
                    result[i] = str
                }
            }
            return result
        }
    }
    return defaultValue
}
```

----------------------------------------

TITLE: Configure Go StreamableHTTP Client with Custom Options
DESCRIPTION: This Go function illustrates how to create a `StreamableHTTPClient` with advanced configuration options. It demonstrates setting custom HTTP timeouts, adding request headers, and providing a custom `http.Client` for fine-grained control over network behavior, including TLS settings.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_5

LANGUAGE: go
CODE:
```
func createCustomStreamableHTTPClient() {
    // Create StreamableHTTP client with options
    c := client.NewStreamableHttpClient("https://api.example.com/mcp",
        transport.WithHTTPTimeout(30*time.Second),
        transport.WithHTTPHeaders(map[string]string{
            "User-Agent": "MyApp/1.0",
            "Accept":     "application/json",
        }),
        transport.WithHTTPBasicClient(&http.Client{
            Transport: &http.Transport{
                MaxIdleConns:        100,
                MaxIdleConnsPerHost: 10,
                IdleConnTimeout:     90 * time.Second,
                TLSClientConfig: &tls.Config{
                    InsecureSkipVerify: false,
                },
            },
        }),
    )
    defer c.Close()

    ctx := context.Background()

    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Use client...
}
```

----------------------------------------

TITLE: Implement a File-Based Static Resource in Go
DESCRIPTION: This Go example shows how to set up an MCP server to serve a static file (README.md) as a resource. It includes the server initialization, adding the resource with its URI and metadata, and a handler function (`handleReadmeFile`) that reads the file content and returns it as a resource result.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_1

LANGUAGE: go
CODE:
```
func main() {
    s := server.NewMCPServer("File Server", "1.0.0",
        server.WithResourceCapabilities(true),
    )

    // Add a static file resource
    s.AddResource(
        mcp.NewResource(
            "file://README.md",
            "Project README",
            mcp.WithResourceDescription("Main project documentation"),
            mcp.WithMIMEType("text/markdown"),
        ),
        handleReadmeFile,
    )

    server.ServeStdio(s)
}

func handleReadmeFile(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    content, err := os.ReadFile("README.md")
    if err != nil {
        return nil, fmt.Errorf("failed to read README: %w", err)
    }

    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            {
                URI:      req.Params.URI,
                MIMEType: "text/markdown",
                Text:     string(content),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Basic SSE Client
DESCRIPTION: Shows how to create and configure a basic SSE (Server-Sent Events) client for real-time communication. The example covers client initialization, setting custom headers (e.g., for authorization), subscribing to server-sent notifications, and performing regular API calls using the SSE client.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_8

LANGUAGE: go
CODE:
```
func createSSEClient() {
    // Create SSE client
    c := client.NewSSEClient("http://localhost:8080/mcp/sse")
    defer c.Close()

    // Set authentication
    c.SetHeader("Authorization", "Bearer your-token")

    ctx := context.Background()

    // Initialize
    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Subscribe to notifications
    notifications, err := c.Subscribe(ctx)
    if err != nil {
        log.Fatal(err)
    }

    // Handle notifications in background
    go func() {
        for notification := range notifications {
            log.Printf("Notification: %+v", notification)
        }
    }()

    // Use client for regular operations
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Available tools: %d", len(tools.Tools))
}
```

----------------------------------------

TITLE: Implement Logging Middleware in Go
DESCRIPTION: This Go code defines a `LoggingMiddleware` struct that wraps `server.ToolHandlerFunc` and `server.ResourceHandler` to log the start, completion, and failure of tool calls and resource reads. It captures session ID, tool/resource name, duration, and errors, providing detailed operational insights for monitoring server activity.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_5

LANGUAGE: go
CODE:
```
type LoggingMiddleware struct {
    logger *log.Logger
}

func NewLoggingMiddleware(logger *log.Logger) *LoggingMiddleware {
    return &LoggingMiddleware{logger: logger}
}

func (m *LoggingMiddleware) ToolMiddleware(next server.ToolHandlerFunc) server.ToolHandlerFunc {
    return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        start := time.Now()
        sessionID := server.GetSessionID(ctx)
        
        m.logger.Printf("Tool call started: tool=%s", req.Params.Name)
        
        result, err := next(ctx, req)
        
        duration := time.Since(start)
        if err != nil {
            m.logger.Printf("Tool call failed: session=%s tool=%s duration=%v error=%v", 
                sessionID, req.Params.Name, duration, err)
        } else {
            m.logger.Printf("Tool call completed: session=%s tool=%s duration=%v", 
                sessionID, req.Params.Name, duration)
        }
        
        return result, err
    }
}

func (m *LoggingMiddleware) ResourceMiddleware(next server.ResourceHandler) server.ResourceHandler {
    return func(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
        start := time.Now()
        sessionID := server.GetSessionID(ctx)
        
        m.logger.Printf("Resource read started: session=%s uri=%s", sessionID, req.Params.URI)
        
        result, err := next(ctx, req)
        
        duration := time.Since(start)
        if err != nil {
            m.logger.Printf("Resource read failed: session=%s uri=%s duration=%v error=%v", 
                sessionID, req.Params.URI, duration, err)
        } else {
            m.logger.Printf("Resource read completed: session=%s uri=%s duration=%v", 
                sessionID, req.Params.URI, duration)
        }
        
        return result, err
    }
}
```

----------------------------------------

TITLE: Applying Tool Filters to MCP Server Sessions in Go
DESCRIPTION: This snippet demonstrates how to configure an MCP server with a global tool filter. The filter function, applied via server.WithToolFilter, allows dynamic control over which tools are visible to a session based on its properties, such as the session ID, enabling role-based or context-aware tool access.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_13

LANGUAGE: Go
CODE:
```
// Add a tool filter that only shows tools with certain prefixes
s := server.NewMCPServer(
    "Tool Filtering Demo",
    "1.0.0",
    server.WithToolCapabilities(true),
    server.WithToolFilter(func(ctx context.Context, tools []mcp.Tool) []mcp.Tool {
        // Get session from context
        session := server.ClientSessionFromContext(ctx)
        if session == nil {
            return tools // Return all tools if no session
        }
        
        // Example: filter tools based on session ID prefix
        if strings.HasPrefix(session.SessionID(), "admin-") {
            // Admin users get all tools
            return tools
        } else {
            // Regular users only get tools with "public-" prefix
            var filteredTools []mcp.Tool
            for _, tool := range tools {
                if strings.HasPrefix(tool.Name, "public-") {
                    filteredTools = append(filteredTools, tool)
                }
            }
            return filteredTools
        }
    }),
)
```

----------------------------------------

TITLE: Add Conditional Tools in Go
DESCRIPTION: This Go function illustrates how to conditionally add tools based on certain criteria, such as user roles. It shows an example of an admin-only tool and a tool available to all users.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_17

LANGUAGE: go
CODE:
```
func addConditionalTools(s *server.MCPServer, userRole string) {
    // Admin-only tools
    if userRole == "admin" {
        adminTool := mcp.NewTool("delete_user",
            mcp.WithDescription("Delete a user account (admin only)"),
            mcp.WithString("user_id", mcp.Required()),
        )
        s.AddTool(adminTool, handleDeleteUser)
    }
    
    // User tools available to all
    userTool := mcp.NewTool("get_profile",
        mcp.WithDescription("Get user profile information"),
    )
    s.AddTool(userTool, handleGetProfile)
}
```

----------------------------------------

TITLE: Adding a Code Review Prompt with Embedded Resource in MCP-Go (Go)
DESCRIPTION: This example illustrates defining a 'code_review' prompt that requires a 'pr_number' argument. It demonstrates embedding an external resource, specifically a 'text/x-diff' content type, allowing the LLM to review code changes directly from a specified pull request URI.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_9

LANGUAGE: Go
CODE:
```
// Code review prompt with embedded resource
s.AddPrompt(mcp.NewPrompt("code_review",
    mcp.WithPromptDescription("Code review assistance"),
    mcp.WithArgument("pr_number",
        mcp.ArgumentDescription("Pull request number to review"),
        mcp.RequiredArgument(),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    prNumber := request.Params.Arguments["pr_number"]
    if prNumber == "" {
        return nil, fmt.Errorf("pr_number is required")
    }
    
    return mcp.NewGetPromptResult(
        "Code review assistance",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleUser,
                mcp.NewTextContent("Review the changes and provide constructive feedback."),
            ),
            mcp.NewPromptMessage(
                mcp.RoleAssistant,
                mcp.NewEmbeddedResource(mcp.ResourceContents{
                    URI: fmt.Sprintf("git://pulls/%s/diff", prNumber),
                    MIMEType: "text/x-diff",
                }),
            ),
        },
    ), nil
})
```

----------------------------------------

TITLE: Go Multi-Transport Client Factory Implementation and Usage
DESCRIPTION: This Go code defines a `ClientFactory` struct and its methods for configuring and creating different types of clients, including stdio, streamable HTTP, and Server-Sent Events (SSE) clients. It centralizes client creation logic, allowing dynamic selection of transport based on configuration. The example `demonstrateClientFactory` illustrates how to set up configurations and create a client.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_14

LANGUAGE: go
CODE:
```
type ClientFactory struct {
    configs map[string]interface{}
}

func NewClientFactory() *ClientFactory {
    return &ClientFactory{
        configs: make(map[string]interface{}),
    }
}

func (cf *ClientFactory) SetStdioConfig(command string, args ...string) {
    cf.configs["stdio"] = client.StdioOptions{
        Command: command,
        Args:    args,
    }
}

func (cf *ClientFactory) SetStreamableHTTPConfig(baseURL string, headers map[string]string) {
    cf.configs["streamablehttp"] = struct {
        BaseURL string
        Headers map[string]string
    }{
        BaseURL: baseURL,
        Headers: headers,
    }
}

func (cf *ClientFactory) SetSSEConfig(baseURL string, headers map[string]string) {
    cf.configs["sse"] = struct {
        BaseURL string
        Headers map[string]string
    }{
        BaseURL: baseURL,
        Headers: headers,
    }
}

func (cf *ClientFactory) CreateClient(transport string) (client.Client, error) {
    switch transport {
    case "stdio":
        config, ok := cf.configs["stdio"].(client.StdioOptions)
        if !ok {
            return nil, fmt.Errorf("stdio config not set")
        }
        return client.NewStdioClientWithOptions(config)

    case "streamablehttp":
        config, ok := cf.configs["streamablehttp"].(struct {
            BaseURL string
            Headers map[string]string
        })
        if !ok {
            return nil, fmt.Errorf("streamablehttp config not set")
        }
        
        options := []transport.StreamableHTTPCOption{}
        if len(config.Headers) > 0 {
            options = append(options, transport.WithHTTPHeaders(config.Headers))
        }
        
        return client.NewStreamableHttpClient(config.BaseURL, options...), nil

    case "sse":
        config, ok := cf.configs["sse"].(struct {
            BaseURL string
            Headers map[string]string
        })
        if !ok {
            return nil, fmt.Errorf("sse config not set")
        }
        
        options := []transport.ClientOption{}
        if len(config.Headers) > 0 {
            options = append(options, transport.WithHeaders(config.Headers))
        }
        
        return client.NewSSEMCPClient(config.BaseURL, options...)

    default:
        return nil, fmt.Errorf("unknown transport: %s", transport)
    }
}

// Usage
func demonstrateClientFactory() {
    factory := NewClientFactory()
    
    // Configure transports
    factory.SetStdioConfig("go", "run", "server.go")
    factory.SetStreamableHTTPConfig("http://localhost:8080/mcp", map[string]string{
        "Authorization": "Bearer token",
    })
    factory.SetSSEConfig("http://localhost:8080/mcp/sse", map[string]string{
        "Authorization": "Bearer token",
    })

    // Create client based on environment
    transport := os.Getenv("MCP_TRANSPORT")
    if transport == "" {
        transport = "stdio"
    }

    client, err := factory.CreateClient(transport)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    // Use client...
}
```

----------------------------------------

TITLE: Create a Basic StdIO MCP Client in Go
DESCRIPTION: This Go program demonstrates how to create a standard I/O MCP client using `mcp-go`. It connects to another MCP server, initializes the connection, lists available tools, and then calls the 'hello_world' tool, printing its result.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/quick-start.mdx#_snippet_4

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
)

func main() {
    // Create a stdio client that connects to another MCP server
	// NTOE: NewStdioMCPClient will start the connection automatically. Don't call the Start method manually
    c, err := client.NewStdioMCPClient(
        "go", "run", "path/to/server/main.go",
    )
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()

    ctx := context.Background()

    // Initialize the connection
    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // List available tools
    tools, err := c.ListTools(ctx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Available tools: %d\n", len(tools.Tools))
    for _, tool := range tools.Tools {
        fmt.Printf("- %s: %s\n", tool.Name, tool.Description)
    }

    // Call a tool
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolParams{
            Name: "hello_world",
            Arguments: map[string]interface{}{
                "name": "World",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // Print the result
    for _, content := range result.Content {
        if content.Type == "text" {
            fmt.Printf("Result: %s\n", content.Text)
        }
    }
}
```

----------------------------------------

TITLE: Implement Custom Validation for File Paths in Go
DESCRIPTION: This Go code demonstrates how to implement custom validation logic using `go-playground/validator` within an MCP-Go application. It defines a `FileOperationInput` struct with a custom 'filepath' validation tag. The `validateFilePath` function prevents directory traversal and ensures file paths are within an allowed directory, enhancing security and data integrity for file operations.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_2

LANGUAGE: go
CODE:
```
import (
    "path/filepath"
    "strings"

    "github.com/go-playground/validator/v10"
)

type FileOperationInput struct {
    Path      string `json:"path" validate:"required,filepath"`
    Operation string `json:"operation" validate:"required,oneof=read write delete"`
    Content   string `json:"content" validate:"required_if=Operation write"`
}

// Custom validator
func init() {
    validate := validator.New()
    validate.RegisterValidation("filepath", validateFilePath)
}

func validateFilePath(fl validator.FieldLevel) bool {
    path := fl.Field().String()
    
    // Prevent directory traversal
    if strings.Contains(path, "..") {
        return false
    }
    
    // Ensure path is within allowed directory
    allowedDir := "/app/data"
    absPath, err := filepath.Abs(path)
    if err != nil {
        return false
    }
    
    return strings.HasPrefix(absPath, allowedDir)
}
```

----------------------------------------

TITLE: Send Real-Time Notifications from Go Tool Handler
DESCRIPTION: This Go function demonstrates how to send real-time notifications from a tool handler within an MCP server. It retrieves the server instance from the context and uses `SendNotificationToClient` to dispatch a custom event with a message and timestamp to the connected client. This enables server-to-client communication for real-time updates.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/sse.mdx#_snippet_3

LANGUAGE: go
CODE:
```
func handleRealtimeTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Get the MCP server from context
    mcpServer := server.ServerFromContext(ctx)
    
    // Send a notification to the client
    if mcpServer != nil {
        err := mcpServer.SendNotificationToClient(ctx, "custom_event", map[string]interface{}{
            "message": "Real-time update",
            "timestamp": time.Now().Unix(),
        })
        if err != nil {
            log.Printf("Failed to send notification: %v", err)
        }
    }
    
    return mcp.NewToolResultText(`{"status":"notification_sent"}`), nil
}
```

----------------------------------------

TITLE: Implementing Basic Client Sessions in Go
DESCRIPTION: This snippet demonstrates how to create an MCP server with session capabilities, define a custom ClientSession implementation (MySession), register and unregister sessions, and send notifications to specific clients. It covers the essential methods required by the ClientSession interface.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_11

LANGUAGE: Go
CODE:
```
// Create a server with session capabilities
s := server.NewMCPServer(
    "Session Demo",
    "1.0.0",
    server.WithToolCapabilities(true),
)

// Implement your own ClientSession
type MySession struct {
    id           string
    notifChannel chan mcp.JSONRPCNotification
    isInitialized bool
    // Add custom fields for your application
}

// Implement the ClientSession interface
func (s *MySession) SessionID() string {
    return s.id
}

func (s *MySession) NotificationChannel() chan<- mcp.JSONRPCNotification {
    return s.notifChannel
}

func (s *MySession) Initialize() {
    s.isInitialized = true
}

func (s *MySession) Initialized() bool {
    return s.isInitialized
}

// Register a session
session := &MySession{
    id:           "user-123",
    notifChannel: make(chan mcp.JSONRPCNotification, 10),
}
if err := s.RegisterSession(context.Background(), session); err != nil {
    log.Printf("Failed to register session: %v", err)
}

// Send notification to a specific client
err := s.SendNotificationToSpecificClient(
    session.SessionID(),
    "notification/update",
    map[string]any{"message": "New data available!"},
)
if err != nil {
    log.Printf("Failed to send notification: %v", err)
}

// Unregister session when done
s.UnregisterSession(context.Background(), session.SessionID())
```

----------------------------------------

TITLE: Passing Session Context to HTTP Handlers in MCP Go
DESCRIPTION: This Go snippet illustrates how to manually attach a client session to an HTTP request context for use in MCP handlers. It shows retrieving a session (e.g., from a cookie) and then using s.WithContext to embed it, ensuring subsequent operations can access session-specific data.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_15

LANGUAGE: Go
CODE:
```
httpHandler := func(w http.ResponseWriter, r *http.Request) {
    // Get session from somewhere (like a cookie or header)
    session := getSessionFromRequest(r)
    
    // Add session to context
    ctx := s.WithContext(r.Context(), session)
    
    // Use this context when handling requests
    // ...
}
```

----------------------------------------

TITLE: Implementing Per-Session Tools with SessionWithTools in Go
DESCRIPTION: This snippet illustrates how to extend basic session handling to support per-session tools by implementing the SessionWithTools interface. It shows how to define GetSessionTools and SetSessionTools methods, register a session with tool support, add session-specific tools, and delete them, allowing for customized tool availability per client.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_12

LANGUAGE: Go
CODE:
```
// Implement SessionWithTools interface for per-session tools
type MyAdvancedSession struct {
    MySession  // Embed the basic session
    sessionTools map[string]server.ServerTool
}

// Implement additional methods for SessionWithTools
func (s *MyAdvancedSession) GetSessionTools() map[string]server.ServerTool {
    return s.sessionTools
}

func (s *MyAdvancedSession) SetSessionTools(tools map[string]server.ServerTool) {
    s.sessionTools = tools
}

// Create and register a session with tools support
advSession := &MyAdvancedSession{
    MySession: MySession{
        id:           "user-456",
        notifChannel: make(chan mcp.JSONRPCNotification, 10),
    },
    sessionTools: make(map[string]server.ServerTool),
}
if err := s.RegisterSession(context.Background(), advSession); err != nil {
    log.Printf("Failed to register session: %v", err)
}

// Add session-specific tools
userSpecificTool := mcp.NewTool(
    "user_data",
    mcp.WithDescription("Access user-specific data"),
)
// You can use AddSessionTool (similar to AddTool)
err := s.AddSessionTool(
    advSession.SessionID(),
    userSpecificTool,
    func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        // This handler is only available to this specific session
        return mcp.NewToolResultText("User-specific data for " + advSession.SessionID()), nil
    },
)
if err != nil {
    log.Printf("Failed to add session tool: %v", err)
}

// Or use AddSessionTools directly with ServerTool
/*
err := s.AddSessionTools(
    advSession.SessionID(),
    server.ServerTool{
        Tool: userSpecificTool,
        Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            // This handler is only available to this specific session
            return mcp.NewToolResultText("User-specific data for " + advSession.SessionID()), nil
        },
    },
)
if err != nil {
    log.Printf("Failed to add session tool: %v", err)
}
*/

// Delete session-specific tools when no longer needed
err = s.DeleteSessionTools(advSession.SessionID(), "user_data")
if err != nil {
    log.Printf("Failed to delete session tool: %v", err)
}
```

----------------------------------------

TITLE: Expose Application Configuration as an MCP Resource in Go
DESCRIPTION: This Go snippet demonstrates how to create a static resource that exposes application configuration. It defines a resource with a `config://app` URI and a handler (`handleAppConfig`) that dynamically constructs a JSON object from environment variables and fixed values, then marshals it to be served as a resource.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_2

LANGUAGE: go
CODE:
```
// Configuration resource
s.AddResource(
    mcp.NewResource(
        "config://app",
        "Application Configuration", 
        mcp.WithResourceDescription("Current application settings"),
        mcp.WithMIMEType("application/json"),
    ),
    handleAppConfig,
)

func handleAppConfig(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    config := map[string]interface{}{
        "database_url": os.Getenv("DATABASE_URL"),
        "debug_mode":   os.Getenv("DEBUG") == "true",
        "version":      "1.0.0",
        "features": []string{
            "authentication",
            "caching", 
            "logging",
        },
    }

    configJSON, err := json.Marshal(config)
    if err != nil {
        return nil, err
    }
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            mcp.TextResourceContent{
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(configJSON),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Serving Binary Content (Image) with MCP-Go Resources
DESCRIPTION: Demonstrates how to serve binary content, such as an image, through an MCP-Go resource. It reads an image file, encodes the binary data into a Base64 string, and sets the appropriate MIME type ('image/png') for the resource's Blob content.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
func handleImageResource(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    imageData, err := os.ReadFile("logo.png")
    if err != nil {
        return nil, err
    }
    
    // Encode binary data as base64
    encoded := base64.StdEncoding.EncodeToString(imageData)
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            {
                URI:      req.Params.URI,
                MIMEType: "image/png",
                Blob:     encoded,
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Handle Multiple Content Types in Go Tool Results
DESCRIPTION: This Go function shows how to return a tool result with multiple content blocks, allowing for a combination of text or other types. It constructs an mcp.CallToolResult with an array of mcp.Content.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_13

LANGUAGE: go
CODE:
```
func handleMultiContentTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    data := map[string]interface{}{
        "name": "John Doe",
        "age":  30,
    }
    
    return &mcp.CallToolResult{
        Content: []mcp.Content{
            {
                Type: "text",
                Text: "User information retrieved successfully",
            },
            {
                Type: "text",
                Text: fmt.Sprintf("Name: %s, Age: %d", data["name"], data["age"]),
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Filter Tools Based on Context in Go
DESCRIPTION: This Go code defines a `ContextFilter` struct and its methods to dynamically filter a list of `mcp.Tool` instances. Tools are filtered based on the current time of day (e.g., maintenance tools only during off-hours) and environment variables (e.g., debug tools only in 'development' environment). It ensures that only relevant tools are available under specific operational conditions.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_11

LANGUAGE: go
CODE:
```
type ContextFilter struct{}

func (f *ContextFilter) FilterTools(ctx context.Context, tools []mcp.Tool) []mcp.Tool {
    timeOfDay := time.Now().Hour()
    environment := os.Getenv("ENVIRONMENT")
    
    var filtered []mcp.Tool
    for _, tool := range tools {
        if f.shouldIncludeTool(tool, timeOfDay, environment) {
            filtered = append(filtered, tool)
        }
    }
    
    return filtered
}

func (f *ContextFilter) shouldIncludeTool(tool mcp.Tool, hour int, env string) bool {
    // Maintenance tools only during off-hours
    maintenanceTools := map[string]bool{
        "backup_database":  true,
        "cleanup_logs":     true,
        "restart_service":  true,
    }
    
    if maintenanceTools[tool.Name] {
        return hour < 6 || hour > 22 // Only between 10 PM and 6 AM
    }
    
    // Debug tools only in development
    debugTools := map[string]bool{
        "debug_session": true,
        "dump_state":    true,
    }
    
    if debugTools[tool.Name] {
        return env == "development"
    }
    
    return true
}
```

----------------------------------------

TITLE: Define Common MCP Go Client Error Types
DESCRIPTION: This Go code defines various custom error types for an MCP client application. Errors are categorized into connection errors (e.g., `ErrConnectionFailed`, `ErrTimeout`), protocol errors (e.g., `ErrInvalidResponse`, `ErrUnsupportedVersion`), and operation errors (e.g., `ErrToolNotFound`, `ErrPermissionDenied`), providing a structured approach to error management.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_7

LANGUAGE: Go
CODE:
```
// Connection errors
var (
    ErrConnectionFailed = errors.New("connection failed")
    ErrConnectionLost   = errors.New("connection lost")
    ErrTimeout          = errors.New("operation timeout")
)

// Protocol errors
var (
    ErrInvalidResponse    = errors.New("invalid response")
    ErrProtocolViolation  = errors.New("protocol violation")
    ErrUnsupportedVersion = errors.New("unsupported protocol version")
)

// Operation errors
var (
    ErrToolNotFound       = errors.New("tool not found")
    ErrResourceNotFound   = errors.New("resource not found")
    ErrInvalidArguments   = errors.New("invalid arguments")
    ErrPermissionDenied   = errors.New("permission denied")
}
```

----------------------------------------

TITLE: Go: Retrieve User Data and Generate MCP JSON Resource
DESCRIPTION: This snippet demonstrates how to fetch user data from a database, handle potential errors, and format the user's information into an MCP `TextResourceContents` object as a JSON string. It also includes helper functions for searching users in a placeholder database and extracting user IDs from URIs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_3

LANGUAGE: Go
CODE:
```
    user, err := getUserFromDB(userID)
    if err != nil {
        return nil, fmt.Errorf("user not found: %s", userID)
    }

    return []mcp.ResourceContents{
        mcp.TextResourceContents{
            URI:      req.Params.URI,
            MIMEType: "application/json",
            Text:     fmt.Sprintf(`{"id":"%s","name":"%s","email":"%s","age":%d}`, user.ID, user.Name, user.Email, user.Age),
        },
    }, nil
}

// Additional helper functions

func searchUsersInDB(query string, limit, offset int) ([]*User, int, error) {
    // Placeholder implementation
    users := []*User{
        {ID: "1", Name: "John Doe", Email: "john@example.com", Age: 30},
        {ID: "2", Name: "Jane Smith", Email: "jane@example.com", Age: 25},
    }
    return users, len(users), nil
}

func extractUserIDFromURI(uri string) string {
    // Extract user ID from URI like "users://123"
    if len(uri) > 8 && uri[:8] == "users://" {
        return uri[8:]
    }
    return uri
}
```

----------------------------------------

TITLE: Handle Multiple Content Types in Go MCP Server
DESCRIPTION: This Go function demonstrates how to serve a single resource with multiple content representations (e.g., JSON and plain text) using the MCP framework. It marshals data into different MIME types for client consumption.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_9

LANGUAGE: go
CODE:
```
func handleMultiFormatResource(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    data := map[string]interface{}{
        "name": "John Doe",
        "age":  30,
        "city": "New York",
    }
    
    // JSON representation
    jsonData, _ := json.Marshal(data)
    
    // Text representation  
    textData := fmt.Sprintf("Name: %s\nAge: %d\nCity: %s", 
        data["name"], data["age"], data["city"])
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            {
                URI:      req.Params.URI,
                MIMEType: "application/json",
                Text:     string(jsonData),
            },
            {
                URI:      req.Params.URI,
                MIMEType: "text/plain", 
                Text:     textData,
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Configure Resource Listing and Discovery in Go MCP Server
DESCRIPTION: This Go `main` function sets up an MCP server with resource capabilities enabled. It demonstrates how to add multiple resources with different URIs, names, descriptions, and MIME types, enabling clients to discover available resources.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_12

LANGUAGE: go
CODE:
```
func main() {
    s := server.NewMCPServer("Resource Server", "1.0.0",
        server.WithResourceCapabilities(true),
    )

    // Add multiple resources
    resources := []struct {
        uri         string
        name        string
        description string
        mimeType    string
        handler     server.ResourceHandler
    }{
        {"docs://readme", "README", "Project documentation", "text/markdown", handleReadme},
        {"config://app", "App Config", "Application settings", "application/json", handleConfig},
        {"users://{id}", "User Profile", "User information", "application/json", handleUser},
    }

    for _, r := range resources {
        s.AddResource(
            mcp.NewResource(r.uri, r.name,
                mcp.WithResourceDescription(r.description),
                mcp.WithMIMEType(r.mimeType),
            ),
            r.handler,
        )
    }

    server.ServeStdio(s)
}
```

----------------------------------------

TITLE: Create Basic STDIO Client in Go
DESCRIPTION: Demonstrates how to create and use a basic STDIO client in Go, which communicates with a server by spawning a subprocess. It covers client initialization and calling a simple method like ListTools.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_0

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "crypto/tls"
    "errors"
    "fmt"
    "log"
    "net/http"
    "os"
    "sync"
    "time"

    "github.com/mark3labs/mcp-go/client"
    "github.com/mark3labs/mcp-go/mcp"
    "github.com/mark3labs/mcp-go/server"
)

func createStdioClient() {
    // Create client that spawns a subprocess
    c, err := client.NewStdioMCPClient(
        "go", []string{}, "run", "/path/to/server/main.go",
    )
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()

    ctx := context.Background()

    // Initialize connection
    if err := c.Initialize(ctx, initRequest); err != nil {
        log.Fatal(err)
    }

    // Use the client
    tools, err := c.ListTools(ctx, listToolsRequest)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Available tools: %d", len(tools.Tools))
}
```

----------------------------------------

TITLE: Go Session State Management Structures and Methods
DESCRIPTION: Defines the `SessionState` and `SessionManager` structs for handling per-user session data, including user ID, permissions, settings, and start time. It provides methods for creating, retrieving, and removing sessions, ensuring thread safety using read-write mutexes.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/advanced.mdx#_snippet_3

LANGUAGE: go
CODE:
```
type SessionState struct {
    UserID      string
    Permissions []string
    Settings    map[string]interface{}
    StartTime   time.Time
}

type SessionManager struct {
    sessions map[string]*SessionState
    mutex    sync.RWMutex
}

func NewSessionManager() *SessionManager {
    return &SessionManager{
        sessions: make(map[string]*SessionState),
    }
}

func (sm *SessionManager) CreateSession(sessionID, userID string, permissions []string) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    sm.sessions[sessionID] = &SessionState{
        UserID:      userID,
        Permissions: permissions,
        Settings:    make(map[string]interface{}),
        StartTime:   time.Now(),
    }
}

func (sm *SessionManager) GetSession(sessionID string) (*SessionState, bool) {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    session, exists := sm.sessions[sessionID]
    return session, exists
}

func (sm *SessionManager) RemoveSession(sessionID string) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    delete(sm.sessions, sessionID)
}
```

----------------------------------------

TITLE: Implement Custom Validation Functions in Go
DESCRIPTION: This Go snippet provides examples of custom validation functions for common data types like email and URL. These functions can be integrated into tool handlers to enforce specific data formats and constraints beyond basic type checking.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_10

LANGUAGE: Go
CODE:
```
func validateEmail(email string) error {
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return fmt.Errorf("invalid email format")
    }
    return nil
}

func validateURL(url string) error {
    parsed, err := url.Parse(url)
    if err != nil {
        return fmt.Errorf("invalid URL format: %w", err)
    }
    
    if parsed.Scheme != "http" && parsed.Scheme != "https" {
        return fmt.Errorf("URL must use http or https scheme")
    }
    
    return nil
}
```

----------------------------------------

TITLE: MCP-Go Per-Session State Management Example
DESCRIPTION: This Go snippet illustrates a pattern for managing state specific to each client session within an MCP server. It defines a SessionState struct and demonstrates how to retrieve the current session ID from the context to access and utilize session-specific data within a tool handler.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_8

LANGUAGE: go
CODE:
```
// Per-session state
type SessionState struct {
    UserID   string
    Settings map[string]interface{}
}

var sessions = make(map[string]*SessionState)

func toolHandler(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    sessionID := server.GetSessionID(ctx)
    state := sessions[sessionID]
    
    // Use session-specific state
    return processWithState(state, req)
}
```

----------------------------------------

TITLE: Customize MCP-Go Server Configuration in Go
DESCRIPTION: Demonstrates how to initialize an MCP server with various options like enabling tool capabilities, adding recovery middleware, and custom hooks.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_5

LANGUAGE: go
CODE:
```
s := server.NewMCPServer(
    "My Server",
    "1.0.0",
    server.WithToolCapabilities(true),
    server.WithRecovery(),
    server.WithHooks(myHooks),
)
```

----------------------------------------

TITLE: Implement Go Subscription Manager for Client Notifications
DESCRIPTION: This Go code defines the `SubscriptionManager` struct and its core methods for managing client subscriptions and dispatching notifications. It includes initialization, starting/stopping the subscription process, and thread-safe methods for adding and removing notification handlers.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_12

LANGUAGE: go
CODE:
```
type SubscriptionManager struct {
    client        client.Client
    subscriber    client.Subscriber
    notifications chan mcp.Notification
    handlers      map[string][]NotificationHandler
    ctx           context.Context
    cancel        context.CancelFunc
    wg            sync.WaitGroup
    mutex         sync.RWMutex
}

type NotificationHandler func(mcp.Notification) error

func NewSubscriptionManager(c client.Client) (*SubscriptionManager, error) {
    subscriber, ok := c.(client.Subscriber)
    if !ok {
        return nil, fmt.Errorf("client does not support subscriptions")
    }

    ctx, cancel := context.WithCancel(context.Background())

    sm := &SubscriptionManager{
        client:     c,
        subscriber: subscriber,
        handlers:   make(map[string][]NotificationHandler),
        ctx:        ctx,
        cancel:     cancel,
    }

    return sm, nil
}

func (sm *SubscriptionManager) Start() error {
    notifications, err := sm.subscriber.Subscribe(sm.ctx)
    if err != nil {
        return fmt.Errorf("failed to subscribe: %w", err)
    }

    sm.notifications = notifications

    sm.wg.Add(1)
    go sm.handleNotifications()

    return nil
}

func (sm *SubscriptionManager) Stop() {
    sm.cancel()
    sm.wg.Wait()
}

func (sm *SubscriptionManager) AddHandler(method string, handler NotificationHandler) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()

    sm.handlers[method] = append(sm.handlers[method], handler)
}

func (sm *SubscriptionManager) RemoveHandler(method string, handler NotificationHandler) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()

    handlers := sm.handlers[method]
    for i, h := range handlers {
        if reflect.ValueOf(h).Pointer() == reflect.ValueOf(handler).Pointer() {
            sm.handlers[method] = append(handlers[:i], handlers[i+1:]...)
            break
        }
    }
}

func (sm *SubscriptionManager) handleNotifications() {
    defer sm.wg.Done()

    for {
        select {
        case notification := <-sm.notifications:
            sm.processNotification(notification)
        case <-sm.ctx.Done():
            return
        }
    }
}

func (sm *SubscriptionManager) processNotification(notification mcp.Notification) {
    sm.mutex.RLock()
    handlers := sm.handlers[notification.Method]
    sm.mutex.RUnlock()

    for _, handler := range handlers {
        if err := handler(notification); err != nil {
            log.Printf("Handler error for %s: %v", notification.Method, err)
        }
    }
}
```

----------------------------------------

TITLE: MCP-Go Client Connection and Tool Invocation
DESCRIPTION: This Go snippet illustrates how to create an MCP client to connect to a server via standard I/O. It shows how to list available tools and call a specific tool, demonstrating the client's active role in consuming server functionalities.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/core-concepts.mdx#_snippet_5

LANGUAGE: go
CODE:
```
// Client example - uses functionality
client := client.NewStdioClient("database-server")
tools, _ := client.ListTools(ctx)
result, _ := client.CallTool(ctx, queryRequest)
```

----------------------------------------

TITLE: Go Basic In-Process Client Usage Example
DESCRIPTION: This Go example demonstrates how to set up and use an in-process client (`client.NewInProcessClient`) to interact directly with an `MCPServer` within the same application. It illustrates server creation, adding a sample tool, client initialization, and making a `CallTool` request without network overhead, showcasing efficient local communication.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_11

LANGUAGE: go
CODE:
```
func createInProcessClient() {
    // Create server
    s := server.NewMCPServer("Test Server", "1.0.0")
    
    // Add tools to server
    s.AddTool(
        mcp.NewTool("test_tool",
            mcp.WithDescription("Test tool"),
            mcp.WithString("input", mcp.Required()),
        ),
        func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
            input := req.Params.Arguments["input"].(string)
            return mcp.NewToolResultText("Processed: " + input), nil
        },
    )

    // Create in-process client
    c := client.NewInProcessClient(s)
    defer c.Close()

    ctx := context.Background()

    // Initialize (no network overhead)
    if err := c.Initialize(ctx); err != nil {
        log.Fatal(err)
    }

    // Use client
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolRequestParams{
            Name: "test_tool",
            Arguments: map[string]interface{}{
                "input": "test data",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Tool result: %+v", result)
}
```

----------------------------------------

TITLE: Demonstrate Go Subscription Manager Usage
DESCRIPTION: This Go function provides a practical example of how to initialize and utilize the `SubscriptionManager`. It demonstrates adding multiple custom handlers for different notification methods, starting the manager to process incoming notifications, and gracefully stopping it after a period.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_13

LANGUAGE: go
CODE:
```
func demonstrateSubscriptionManager(c client.Client) {
    sm, err := NewSubscriptionManager(c)
    if err != nil {
        log.Printf("Failed to create subscription manager: %v", err)
        return
    }

    // Add handlers
    sm.AddHandler("notifications/progress", func(n mcp.Notification) error {
        log.Printf("Progress notification: %+v", n)
        return nil
    })

    sm.AddHandler("notifications/message", func(n mcp.Notification) error {
        log.Printf("Message notification: %+v", n)
        return nil
    })

    // Start handling
    if err := sm.Start(); err != nil {
        log.Printf("Failed to start subscription manager: %v", err)
        return
    }

    // Let it run for a while
    time.Sleep(30 * time.Second)

    // Stop
    sm.Stop()
}
```

----------------------------------------

TITLE: Configure Go SSE Server Options and Endpoints
DESCRIPTION: This Go snippet illustrates how to configure various options for an SSE server, including setting a static base path, defining the keep-alive interval, specifying the base URL, and customizing SSE and message endpoints. It also shows how to add a custom context function for request processing, leading to specific resulting endpoints for SSE streams and messages.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/sse.mdx#_snippet_2

LANGUAGE: go
CODE:
```
sseServer := server.NewSSEServer(s,
    // Set the base path for SSE endpoints
    server.WithStaticBasePath("/api/mcp"),
    
    // Configure keep-alive interval
    server.WithKeepAliveInterval(30*time.Second),
    
    // Set base URL for client connections
    server.WithBaseURL("http://localhost:8080"),
    
    // Configure SSE and message endpoints
    server.WithSSEEndpoint("/sse"),
    server.WithMessageEndpoint("/message"),
    
    // Add context function for request processing
    server.WithSSEContextFunc(func(ctx context.Context, r *http.Request) context.Context {
        // Add custom context values from headers
        return ctx
    }),
)
```

----------------------------------------

TITLE: Filter MCP Go Resources by Type or URI Pattern
DESCRIPTION: This Go code provides functions to filter MCP resources. `listResourcesByType` filters resources by their MIME type, while `listResourcesByPattern` uses a regular expression to match resource URIs. It also includes usage examples for both filtering methods.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/operations.mdx#_snippet_1

LANGUAGE: go
CODE:
```
func listResourcesByType(ctx context.Context, c client.Client, mimeType string) ([]mcp.Resource, error) {
    resources, err := c.ListResources(ctx)
    if err != nil {
        return nil, err
    }

    var filtered []mcp.Resource
    for _, resource := range resources.Resources {
        if resource.MIMEType == mimeType {
            filtered = append(filtered, resource)
        }
    }

    return filtered, nil
}

func listResourcesByPattern(ctx context.Context, c client.Client, pattern string) ([]mcp.Resource, error) {
    resources, err := c.ListResources(ctx)
    if err != nil {
        return nil, err
    }

    regex, err := regexp.Compile(pattern)
    if err != nil {
        return nil, fmt.Errorf("invalid pattern: %w", err)
    }

    var filtered []mcp.Resource
    for _, resource := range resources.Resources {
        if regex.MatchString(resource.URI) {
            filtered = append(filtered, resource)
        }
    }

    return filtered, nil
}

// Usage examples
func demonstrateResourceFiltering(ctx context.Context, c client.Client) {
    // Find all JSON resources
    jsonResources, err := listResourcesByType(ctx, c, "application/json")
    if err != nil {
        log.Printf("Error listing JSON resources: %v", err)
    } else {
        fmt.Printf("Found %d JSON resources\n", len(jsonResources))
    }

    // Find all user-related resources
    userResources, err := listResourcesByPattern(ctx, c, `users?://.*`)
    if err != nil {
        log.Printf("Error listing user resources: %v", err)
    } else {
        fmt.Printf("Found %d user resources\n", len(userResources))
    }
}
```

----------------------------------------

TITLE: Create In-Process MCP Client in Go
DESCRIPTION: Example of creating an In-Process MCP client, useful for testing, embedded scenarios, and high-performance applications, by directly providing a server instance.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_4

LANGUAGE: go
CODE:
```
// Create in-process client
client := client.NewInProcessClient(server)
```

----------------------------------------

TITLE: Configure custom options for HTTP and SSE transports in Go
DESCRIPTION: Shows how to apply transport-specific options, such as custom endpoint paths for HTTP (`server.WithEndpointPath`, `server.WithStateless`) and SSE (`server.WithSSEEndpoint`, `server.WithMessageEndpoint`, `server.WithKeepAlive`), when creating and starting MCP servers.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_8

LANGUAGE: Go
CODE:
```
// HTTP with custom options
httpServer := server.NewStreamableHTTPServer(s,
    server.WithEndpointPath("/mcp"),
    server.WithStateless(true),
)

if err := httpServer.Start(":8080"); err != nil {
    log.Fatal(err)
}

// SSE with custom options
sseServer := server.NewSSEServer(s,
    server.WithSSEEndpoint("/events"),
    server.WithMessageEndpoint("/message"),
    server.WithKeepAlive(true),
)

if err := sseServer.Start(":8080"); err != nil {
    log.Fatal(err)
}
```

----------------------------------------

TITLE: Implement Custom MCP-Go STDIO Client
DESCRIPTION: This Go code illustrates how to create a custom client for an MCP-Go STDIO server. It demonstrates initializing the client, listing available tools, and calling a specific tool (e.g., 'list_files') with arguments, then printing the results.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_3

LANGUAGE: go
CODE:
```
package main

import (
    "context"
    "log"

    "github.com/mark3labs/mcp-go/client"
)

func main() {
    // Create STDIO client
    c, err := client.NewStdioClient(
        "go", "run", "/path/to/server/main.go",
    )
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()

    ctx := context.Background()

    // Initialize connection
    _, err = c.Initialize(ctx, mcp.InitializeRequest{
        Params: mcp.InitializeRequestParams{
            ProtocolVersion: "2024-11-05",
            Capabilities: mcp.ClientCapabilities{
                Tools: &mcp.ToolsCapability{},
            },
            ClientInfo: mcp.Implementation{
                Name:    "test-client",
                Version: "1.0.0",
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    // List available tools
    tools, err := c.ListTools(ctx, mcp.ListToolsRequest{})
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Available tools: %d", len(tools.Tools))
    for _, tool := range tools.Tools {
        log.Printf("- %s: %s", tool.Name, tool.Description)
    }

    // Call a tool
    result, err := c.CallTool(ctx, mcp.CallToolRequest{
        Params: mcp.CallToolParams{
            Name: "list_files",
            Arguments: map[string]interface{}{
                "path":      ".",
                "recursive": false,
            },
        },
    })
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Tool result: %+v", result)
}
```

----------------------------------------

TITLE: Create SSE MCP Client in Go
DESCRIPTION: Example of creating an SSE (Server-Sent Events) MCP client, best suited for real-time web applications and streaming data scenarios, using the SSE endpoint.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// Create SSE client
client := client.NewSSEMCPClient("http://localhost:8080/mcp/sse")
```

----------------------------------------

TITLE: Go: Create StreamableHTTP MCP Client
DESCRIPTION: Shows how to create a StreamableHTTP client, configuring it with options like timeout, custom headers, and a custom HTTP client.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/basics.mdx#_snippet_2

LANGUAGE: go
CODE:
```
func createStreamableHTTPClient() client.Client {
    // Basic StreamableHTTP client
	httpTransport, err := transport.NewStreamableHTTP(server.URL,
		// Set timeout
		transport.WithHTTPTimeout(30*time.Second),
		// Set custom headers
		transport.WithHTTPHeaders(map[string]string{
			"X-Custom-Header": "custom-value",
			"Y-Another-Header": "another-value",
		}),
		// With custom HTTP client
		transport.WithHTTPBasicClient(&http.Client{}),
	)
    if err != nil {
        log.Fatalf("Failed to create StreamableHTTP transport: %v", err)
    }
    c := client.NewClient(httpTransport)
    return c
}
```

----------------------------------------

TITLE: Configuring MCP Server and OAuth Redirect URIs in Go
DESCRIPTION: This Go snippet defines constants for the MCP server URL and the OAuth redirect URI. These values are crucial for the client to connect to the correct server endpoint and for the OAuth authorization server to redirect back to the local callback server after user authorization.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/examples/oauth_client/README.md#_snippet_1

LANGUAGE: Go
CODE:
```
const (
    // Replace with your MCP server URL
    serverURL = "https://api.example.com/v1/mcp"
    // Use a localhost redirect URI for this example
    redirectURI = "http://localhost:8085/oauth/callback"
)
```

----------------------------------------

TITLE: Create STDIO MCP Client in Go
DESCRIPTION: Example of creating an STDIO MCP client, suitable for command-line applications and local development, by specifying the server command and its arguments.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/index.mdx#_snippet_1

LANGUAGE: go
CODE:
```
// Create STDIO client
client, err := client.NewStdioMCPClient("server-command", "arg1", "arg2")
```

----------------------------------------

TITLE: Create Interactive MCP-Go Server Test Script
DESCRIPTION: This Bash script provides a template for an interactive testing environment for an MCP-Go STDIO server. It sets up the server command, allowing for further interactive commands to be added for comprehensive testing.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_5

LANGUAGE: bash
CODE:
```
#!/bin/bash

# interactive_test.sh
SERVER_CMD="go run main.go"

echo "Starting MCP STDIO server test..."
```

----------------------------------------

TITLE: Define an MCP Resource for Documentation in Go
DESCRIPTION: Example of defining a 'docs://readme' resource using `mcp.NewResource` with a description and MIME type, exposing project documentation to LLMs.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_4

LANGUAGE: go
CODE:
```
resource := mcp.NewResource(
    "docs://readme",
    "Project README",
    mcp.WithResourceDescription("The project's README file"),
    mcp.WithMIMEType("text/markdown"),
)
```

----------------------------------------

TITLE: Standard MCP Server Endpoints
DESCRIPTION: Lists the default HTTP endpoints automatically created by a StreamableHTTP MCP server, detailing their methods and paths for various MCP functionalities like initialization, tool management, resource handling, prompt retrieval, health checks, and server capabilities.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_6

LANGUAGE: APIDOC
CODE:
```
POST /mcp/initialize     - Initialize MCP session
POST /mcp/tools/list     - List available tools
POST /mcp/tools/call     - Call a tool
POST /mcp/resources/list - List available resources
POST /mcp/resources/read - Read a resource
POST /mcp/prompts/list   - List available prompts
POST /mcp/prompts/get    - Get a prompt
GET  /mcp/health         - Health check
GET  /mcp/capabilities   - Server capabilities
```

----------------------------------------

TITLE: Installing MCP Go Library
DESCRIPTION: This Bash command installs the MCP Go library using the `go get` utility. It fetches the latest version of the `github.com/mark3labs/mcp-go` package and its dependencies, making them available for use in Go projects. This is the standard way to add external Go modules to a project.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_1

LANGUAGE: Bash
CODE:
```
go get github.com/mark3labs/mcp-go
```

----------------------------------------

TITLE: Adding a Simple Greeting Prompt in MCP-Go (Go)
DESCRIPTION: This snippet demonstrates how to define a basic 'greeting' prompt. It includes an optional 'name' argument and constructs a friendly text message using the provided name, defaulting to 'friend' if no name is given. This showcases simple text content generation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_8

LANGUAGE: Go
CODE:
```
// Simple greeting prompt
s.AddPrompt(mcp.NewPrompt("greeting",
    mcp.WithPromptDescription("A friendly greeting prompt"),
    mcp.WithArgument("name",
        mcp.ArgumentDescription("Name of the person to greet"),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    name := request.Params.Arguments["name"]
    if name == "" {
        name = "friend"
    }
    
    return mcp.NewGetPromptResult(
        "A friendly greeting",
        []mcp.PromptMessage{
            mcp.NewPromptMessage(
                mcp.RoleAssistant,
                mcp.NewTextContent(fmt.Sprintf("Hello, %s! How can I help you today?", name)),
            ),
        },
    ), nil
})
```

----------------------------------------

TITLE: Example Standard MCP Tool Call Response JSON
DESCRIPTION: Provides the JSON-RPC format for a successful standard MCP response. It includes the jsonrpc version, request id, and the result object, which contains a content array with a text type entry holding the actual JSON response from the tool.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_9

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"users\":[...],\"total\":25,\"limit\":10,\"offset\":0}"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Define Go Connection Error Constants
DESCRIPTION: This Go snippet defines a set of standard error variables for common connection-related issues such as lost connections, failed connections, unauthorized access, and forbidden operations. These constants provide clear, reusable error types for client implementations.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/clients/transports.mdx#_snippet_3

LANGUAGE: go
CODE:
```
// Define connection error constants
var (
    ErrConnectionLost   = errors.New("connection lost")
    ErrConnectionFailed = errors.New("connection failed")
    ErrUnauthorized     = errors.New("unauthorized")
    ErrForbidden        = errors.New("forbidden")
)
```

----------------------------------------

TITLE: Add custom metadata to MCP server in Go
DESCRIPTION: Shows how to include additional server information, such as instructions, using `server.WithInstructions()` during server initialization.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/basics.mdx#_snippet_4

LANGUAGE: Go
CODE:
```
s := server.NewMCPServer(
    "My Server",
    "1.0.0",
    server.WithInstructions("A server that does amazing things"),
)
```

----------------------------------------

TITLE: Test MCP-Go STDIO Server via Command Line
DESCRIPTION: These Bash commands demonstrate how to manually test an MCP-Go STDIO server by sending JSON-RPC messages directly via standard input. It covers initialization, listing tools, and calling a tool, useful for debugging server behavior.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_4

LANGUAGE: bash
CODE:
```
# Start your server
go run main.go

# Send initialization request
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{"tools":{}},"clientInfo":{"name":"test","version":"1.0.0"}}}' | go run main.go

# List tools
echo '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' | go run main.go

# Call a tool
echo '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"list_files","arguments":{"path":".","recursive":false}}}' | go run main.go
```

----------------------------------------

TITLE: Send JSON-RPC Requests to MCP Server (Bash)
DESCRIPTION: This Bash script defines a helper function `send_request` to send JSON-RPC messages to an MCP server via standard input. It then demonstrates various MCP protocol interactions, including initialization, listing tools and resources, and calling a tool with specific arguments.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_6

LANGUAGE: bash
CODE:
```
send_request() {
    local request="$1"
    echo "Sending: $request"
    echo "$request" | $SERVER_CMD
    echo "---"
}

# Initialize
send_request '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{"tools":{}},"clientInfo":{"name":"test","version":"1.0.0"}}}'

# List tools
send_request '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}'

# List resources
send_request '{"jsonrpc":"2.0","id":3,"method":"resources/list","params":{}}'

# Call tool
send_request '{"jsonrpc":"2.0","id":4,"method":"tools/call","params":{"name":"list_files","arguments":{"path":".","recursive":false}}}'

echo "Test completed."
```

----------------------------------------

TITLE: Install MCP-Go Library
DESCRIPTION: Instructions to add the MCP-Go library to your Go project using the `go get` command.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/getting-started.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
go get github.com/mark3labs/mcp-go
```

----------------------------------------

TITLE: Configure Claude Desktop for MCP-Go Server
DESCRIPTION: This JSON snippet shows how to configure Claude Desktop to connect to an MCP-Go STDIO server. It specifies the command to run the server, arguments, and environment variables, allowing Claude Desktop to spawn and communicate with the server.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_2

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "file-tools": {
      "command": "go",
      "args": ["run", "/path/to/your/server/main.go"],
      "env": {
        "LOG_LEVEL": "info"
      }
    }
  }
}
```

----------------------------------------

TITLE: Return Text Results from MCP-Go Tools
DESCRIPTION: This Go function demonstrates how to return a simple text message as a result from an MCP-Go tool using mcp.NewToolResultText. This is suitable for operations that produce a straightforward string output.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/tools.mdx#_snippet_11

LANGUAGE: Go
CODE:
```
func handleTextTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    message := "Operation completed successfully"
    return mcp.NewToolResultText(message), nil
}
```

----------------------------------------

TITLE: Example MCP Error Response JSON
DESCRIPTION: Shows the JSON-RPC format for an error response from the MCP server. It includes the jsonrpc version, request id, and an error object containing a code, message, and optional data for additional details.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_10

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Invalid params",
    "data": {
      "details": "user_id is required"
    }
  }
}
```

----------------------------------------

TITLE: Serving Plain Text Content with MCP-Go Resources
DESCRIPTION: Shows a simple handler function for an MCP-Go resource that serves static plain text content. It sets the MIME type to 'text/plain' and returns the text directly within the resource result.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/servers/resources.mdx#_snippet_6

LANGUAGE: Go
CODE:
```
func handleTextResource(ctx context.Context, req mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
    content := "This is plain text content"
    
    return &mcp.ReadResourceResult{
        Contents: []mcp.ResourceContent{
            {
                URI:      req.Params.URI,
                MIMEType: "text/plain",
                Text:     content,
            },
        },
    }, nil
}
```

----------------------------------------

TITLE: Example MCP Tool Call Request JSON
DESCRIPTION: Illustrates the JSON-RPC format for a standard MCP request, specifically for calling a tool. It shows the jsonrpc version, request id, method name (tools/call), and params including the tool name and its arguments.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/http.mdx#_snippet_8

LANGUAGE: json
CODE:
```
POST /mcp/tools/call
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "search_users",
    "arguments": {
      "query": "john",
      "limit": 10,
      "offset": 0
    }
  }
}
```

----------------------------------------

TITLE: Invoking Go Code Generation
DESCRIPTION: This command executes all `go generate` directives found within the current Go module and its subdirectories. In this project, it specifically triggers the generation of `server/request_handler.go` and `server/hooks.go` from their respective template files, ensuring code consistency and reducing manual boilerplate.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/server/internal/gen/README.md#_snippet_0

LANGUAGE: Shell
CODE:
```
go generate ./...
```

----------------------------------------

TITLE: Running the MCP Go OAuth Client Example
DESCRIPTION: This snippet shows how to set optional environment variables for client ID and secret, and then execute the Go OAuth client example. These variables are typically used for dynamic client registration or pre-configured client credentials.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/examples/oauth_client/README.md#_snippet_0

LANGUAGE: Bash
CODE:
```
export MCP_CLIENT_ID=your_client_id
export MCP_CLIENT_SECRET=your_client_secret

go run main.go
```

----------------------------------------

TITLE: Integrate MCP Inspector for Visual Debugging (Bash)
DESCRIPTION: This snippet provides Bash commands to install the MCP Inspector globally and then run a Go MCP server with the inspector. The MCP Inspector provides a web-based interface for visual debugging, allowing users to view tools, test calls, and inspect protocol messages.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/www/docs/pages/transports/stdio.mdx#_snippet_8

LANGUAGE: bash
CODE:
```
# Install MCP Inspector
npm install -g @modelcontextprotocol/inspector

# Run your server with inspector
mcp-inspector go run main.go
```

----------------------------------------

TITLE: Regenerating Server Code in MCP Go
DESCRIPTION: This Bash command regenerates server hooks and request handlers for an MCP Go project. It requires `go` and `goimports` to be installed, as `goimports` is automatically run for formatting and fixing imports after generation.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/README.md#_snippet_16

LANGUAGE: Bash
CODE:
```
go generate ./...
```

----------------------------------------

TITLE: Check Go Version
DESCRIPTION: Command to verify the installed Go version on your machine. Go 1.23 or later is required for development.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/CONTRIBUTING.md#_snippet_0

LANGUAGE: Bash
CODE:
```
go version
```

----------------------------------------

TITLE: Install Go Module Dependencies
DESCRIPTION: Command to install and tidy up the required Go module dependencies for the project, ensuring all necessary packages are available.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/CONTRIBUTING.md#_snippet_2

LANGUAGE: Bash
CODE:
```
go mod tidy
```

----------------------------------------

TITLE: Clone MCP Go SDK Repository
DESCRIPTION: Commands to clone your forked repository and navigate into the project directory, which is the first step after forking.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/CONTRIBUTING.md#_snippet_1

LANGUAGE: Bash
CODE:
```
git clone https://github.com/YOUR_USERNAME/mcp-go.git
cd mcp-go
```

----------------------------------------

TITLE: Run Go Project Tests
DESCRIPTION: Command to execute all tests within the Go project from the root directory. It's crucial to run tests before submitting a pull request.
SOURCE: https://github.com/mark3labs/mcp-go/blob/main/CONTRIBUTING.md#_snippet_3

LANGUAGE: Bash
CODE:
```
go test -v './...'
```